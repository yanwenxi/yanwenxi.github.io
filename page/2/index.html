<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人博客">
<meta property="og:url" content="http://yanwenxi.github.io/page/2/index.html">
<meta property="og:site_name" content="闫文喜的个人博客">
<meta property="og:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人博客">
<meta name="twitter:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Wenxi Yan</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">我的小窝</a></li>
                        
                            <li><a href="/archives">文章列表</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                            
                                <a class="fl wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-1px/" style="font-size: 10px;">css 1px</a> <a href="/tags/css-前端开发/" style="font-size: 10px;">css 前端开发</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css3/" style="font-size: 10px;">flex css3</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/i18n/" style="font-size: 10px;">i18n</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试-Benchmark-jsPerf/" style="font-size: 10px;">js 性能调试 Benchmark jsPerf</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/js继承、原型链/" style="font-size: 10px;">js继承、原型链</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/nginx/" style="font-size: 12.5px;">nginx</a> <a href="/tags/node/" style="font-size: 12.5px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 20px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 17.5px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 20px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vue、mvvm/" style="font-size: 10px;">vue、mvvm</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 15px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端工程-构建工具-前端开发/" style="font-size: 10px;">前端工程 构建工具 前端开发</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com">前端小站</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://ywxi.github.io/">web博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">运动健身、网络营销、web前端、喜欢接触新鲜事物、迎接新的挑战</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Wenxi Yan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Wenxi Yan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">我的小窝</a></li>
                
                    <li><a href="/archives">文章列表</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-rengemianju" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/19/rengemianju/" class="article-date">
      <time datetime="2017-02-19T09:32:10.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/rengemianju/">人格面具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>
<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>
<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>
<h4 id="人格面具"><a href="#人格面具" class="headerlink" title="人格面具"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>
<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>
<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>
<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>
<h4 id="你看到的未必就是真实，你以为的也不过就是你以为而已。"><a href="#你看到的未必就是真实，你以为的也不过就是你以为而已。" class="headerlink" title="你看到的未必就是真实，你以为的也不过就是你以为而已。"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>
<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>
<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>
<h4 id="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"><a href="#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。" class="headerlink" title="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>
<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>
<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>
<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>
<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>
<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-lovestart" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/14/lovestart/" class="article-date">
      <time datetime="2017-02-14T09:15:48.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/lovestart/">爱的开始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <iframe style="margin:0 auto; display:block;" frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66"></iframe>

<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>
<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>
<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>
<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>
<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>
<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>
<h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>
<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-web-workers" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/10/web-workers/" class="article-date">
      <time datetime="2017-02-10T03:53:05.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/web-workers/">程序性能之HTML5 Web Workers</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="什么是-Web-Worker？"><a href="#什么是-Web-Worker？" class="headerlink" title="什么是 Web Worker？"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>
<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>也可以发送 “message” 事件给这个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.postMessage( &quot;something cool to say&quot; );</div></pre></td></tr></table></figure></p>
<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// &quot;mycoolworker.js&quot;</div><div class="line">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div><div class="line">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</div></pre></td></tr></table></figure></p>
<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>
<h4 id="Web-Worker-通常应用于哪些方面呢？"><a href="#Web-Worker-通常应用于哪些方面呢？" class="headerlink" title="Web Worker 通常应用于哪些方面呢？"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if(typeof(Worker)!==&quot;undefined&quot;)</div><div class="line">  &#123;</div><div class="line">  // Yes! Web worker support!</div><div class="line">  // Some code.....</div><div class="line">  &#125;</div><div class="line">else</div><div class="line">  &#123;</div><div class="line">  // Sorry! No Web Worker support..</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Worker环境"><a href="#Worker环境" class="headerlink" title="Worker环境"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 在Worker内部</div><div class="line">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>
<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href="https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）" target="_blank" rel="external">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>
<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href="http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，" target="_blank" rel="external">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>
<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href="http://developer.mozilla.org/enUS/docs/Web/API/Transferable" target="_blank" rel="external">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 比如foo是一个Uint8Array</div><div class="line">postMessage( foo.buffer, [ foo.buffer ] );</div></pre></td></tr></table></figure></p>
<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>
<h4 id="共享-Worker"><a href="#共享-Worker" class="headerlink" title="共享 Worker"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class="line">// ..</div><div class="line">w1.port.postMessage( &quot;something cool&quot; );</div></pre></td></tr></table></figure></p>
<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.port.start();</div></pre></td></tr></table></figure></p>
<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在共享Worker内部</div><div class="line">addEventListener( &quot;connect&quot;, function(evt)&#123;</div><div class="line">// 这个连接分配的端口</div><div class="line">var port = evt.ports[0];</div><div class="line">port.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// ..</div><div class="line">port.postMessage( .. );</div><div class="line">// ..</div><div class="line">&#125; );</div><div class="line">// 初始化端口连接</div><div class="line">port.start();</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件（ 即程序） ， 使用异步事件在线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程中，以提高主 UI 线程的响应性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h5-webworkers/">h5 webworkers</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-deepthis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/07/deepthis/" class="article-date">
      <time datetime="2017-02-07T02:43:40.000Z" itemprop="datePublished">2017-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/07/deepthis/">关于this那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="this的简单理解"><a href="#this的简单理解" class="headerlink" title="this的简单理解"></a>this的简单理解</h4><p>this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call()、apply()和bind()用来改变this关键字的</div><div class="line">function.call(thisObj,参数1，参数2....)</div><div class="line">function.apply(thisObj,[参数1，参数2....])</div><div class="line">function.bind(thisObj，参数1,参数2...)</div></pre></td></tr></table></figure></p>
<p>call和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line"> this.count++;</div><div class="line">&#125; </div><div class="line">foo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。</div><div class="line">foo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。</div><div class="line">foo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;</div></pre></td></tr></table></figure></p>
<p>总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p>
<h4 id="严格与非严格模式下的this"><a href="#严格与非严格模式下的this" class="headerlink" title="严格与非严格模式下的this"></a>严格与非严格模式下的this</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // 2，此时函数里的this默认指向全局window。</div></pre></td></tr></table></figure>
<p>如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>
<p>虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">(function()&#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">foo(); // 2</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">a: 42,</div><div class="line">foo: foo</div><div class="line">&#125;;</div><div class="line">var obj1 = &#123;</div><div class="line">a: 2,</div><div class="line">obj2: obj2</div><div class="line">&#125;;</div><div class="line">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>
<p>函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.<br>当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。</p>
<p>注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则<br>this 会被绑定到全局对象。</p>
<h4 id="判断this的规则"><a href="#判断this的规则" class="headerlink" title="判断this的规则"></a>判断this的规则</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</p>
<ul>
<li>1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。</li>
<li>2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</li>
<li>3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</li>
<li>4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()</li>
<li>5.定时器中的this一直指向window.</li>
</ul>
<h4 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125; v</div><div class="line">ar a = 2;</div><div class="line">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>
<p>那么什么情况下会传入 null 呢？<br>一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 把数组“ 展开” 成参数</div><div class="line">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( null, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。<br>小提示：在 ES6 中， 可以用 … 操作符代替 apply(..) 来“ 展开” 数组， foo(…[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。</p>
<p>然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览<br>器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。</p>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h4><p>一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。<br>在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 定义的 DMZ 空对象</div><div class="line">var ø = Object.create( null );//ø为变量名，可以随便起。</div><div class="line">// 把数组展开成参数</div><div class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( ø, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。</p>
<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h4><p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 =&gt; 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">// 返回一个箭头函数</div><div class="line">return (a) =&gt; &#123;</div><div class="line">//this 继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">var obj2 = &#123;</div><div class="line">a:3</div><div class="line">&#125;;</div><div class="line">var bar = foo.call( obj1 );</div><div class="line">bar.call( obj2 ); // 2, 不是 3 ！</div></pre></td></tr></table></figure></p>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不<br>行！ ）<br>箭头函数最常用于回调函数中， 例如事件处理器或者定时器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">// 这里的 this 在此法上继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;,100);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-this/">js this</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-deepclosure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/deepclosure/" class="article-date">
      <time datetime="2017-02-06T09:32:12.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/deepclosure/">深入理解闭包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">bar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a</div><div class="line">&#125; </div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125;</div><div class="line">return bar;</div><div class="line">&#125;</div><div class="line">var baz = foo();</div><div class="line">baz(); // 2 —— 这才是闭包</div></pre></td></tr></table></figure></p>
<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</p>
<p> 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。<br> 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125; </div><div class="line">bar( baz );</div><div class="line">&#125;</div><div class="line">function bar(fn) &#123;</div><div class="line">fn(); // 快看呀， 这就是闭包！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var fn;</div><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125; </div><div class="line">fn = baz; // 将 baz 分配给全局变量</div><div class="line">&#125;</div><div class="line">function bar() &#123;</div><div class="line">fn(); // 妈妈快看呀， 这就是闭包！</div><div class="line">&#125; </div><div class="line">foo();</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure></p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。</p>
<h4 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）</p>
<p>正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function() &#123;</div><div class="line">var j = i;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以对上面代码进行一些改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function(j) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<font color="red">也可以用块作用域来实现</font>

<p>使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">let j = i; // 是的， 闭包的块作用域！</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-closure/">js closure</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxapp-online" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxapp-online/" class="article-date">
      <time datetime="2017-02-06T08:07:17.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxapp-online/">简易电商类小程序开发教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。<br>在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。</p>
<h4 id="1、准备开工"><a href="#1、准备开工" class="headerlink" title="1、准备开工"></a>1、准备开工</h4><p>先新建一个文件夹 wxapponline 作为项目目录，里面包含：<br>   1.common 目录——用来放置项目公用的文件<br>   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件<br>   3.templates 目录——用来放置自定义的组件<br>   4.utils 目录——用来放置工具类 js 文件<br>   5.app.js——小程序逻辑<br>   6.app.json——小程序公共设置<br>   7.app.wxss——小程序公共样式表</p>
<h4 id="2、轮播banner样式定义"><a href="#2、轮播banner样式定义" class="headerlink" title="2、轮播banner样式定义"></a>2、轮播banner样式定义</h4><p>和大多数项目一样，最开始是首页的实现。<br>首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。</p>
<font color="red">实现 banner 轮播图，来看代码：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;swiper class=&quot;banner-swiper&quot;</div><div class="line">indicator-dots=&quot;&#123;&#123; indicatorDots &#125;&#125;&quot;</div><div class="line">autoplay=&quot;&#123;&#123; autoplay &#125;&#125;&quot; interval=&quot;&#123;&#123; interval &#125;&#125;&quot;</div><div class="line">duration=&quot;&#123;&#123; duration &#125;&#125;&quot;&gt;</div><div class="line">&lt;swiper-item class=&quot;swiper-item&quot;</div><div class="line">wx:for=&quot;&#123;&#123; banners &#125;&#125;&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../detail/detail?id=&#123;&#123; item.productId &#125;&#125;&quot;&gt;</div><div class="line">&lt;image src=&quot;&#123;&#123; item.image &#125;&#125;&quot;</div><div class="line">class=&quot;slide-image&quot;&gt;&lt;/image&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/swiper-item&gt;</div><div class="line">&lt;/swiper&gt;</div></pre></td></tr></table></figure><br><br>值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;<br>友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。<br>另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。<br>如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。<br>在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。<br><br>#### 3.准备获取 banner    数据，并绑定到视图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*** index.js ***/</div><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">banners: [], //初始化一个 banners 数组</div><div class="line">//以下四项设置 swiper 组件的参数值</div><div class="line">indicatorDots: true</div><div class="line">, autoplay: true, //开启自动切换</div><div class="line">interval: 5000, //自动切换时间间隔</div><div class="line">duration: 1000 //滑动动画时长&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br>在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。<br>友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。<br><br>实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。<br>注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。<br><br>#### 4.从服务器获取 banner数据<br>现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发<br>起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. url：设置发送请求的地址。</div><div class="line">2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。</div><div class="line">3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：</div><div class="line">res = &#123;data: &apos;服务器返回的数据&apos;, errMsg: &apos;错误信息&apos;, statusCode: HTTP 状态码&#125;</div></pre></td></tr></table></figure><br><br>特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。<br>我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*** config.js ***/</div><div class="line">const CONFIG = &#123;</div><div class="line">API_URL: &#123;</div><div class="line">BANNER_QUERY: http://ifanr.com/api/banner</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">module.exports = CONFIG;</div><div class="line">然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：</div><div class="line">/*** index.js ***/</div><div class="line">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class="line">于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：</div><div class="line">/*** index.js ***/</div><div class="line">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class="line">Page(&#123;</div><div class="line">data: &#123;...</div><div class="line">&#125;,</div><div class="line">onLoad: function () &#123;</div><div class="line">var _this = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.BANNER_QUERY,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">limit: 6,</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,</div><div class="line">success: function (res) &#123;</div><div class="line">if (res.statusCode == 200) &#123;</div><div class="line">_this.setData(&#123;</div><div class="line">banners: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br>在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。<br>注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。<br><br>## 如何做商品列表<br>#### 1.为布局而生的 Flex<br>传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。<br><br>而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。<br>#### 2.如何更方便地使用 rpx<br>rpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏<br>幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。<br><br>例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。<br>其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。<br><br>简单一句话解释：量取多少就设置多少。<br><br>#### 3.Flex配合rpx的使用案例<br>现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。<br>第一个例子：货架列表效果图：<br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg" alt=""><br></div><br><br>首先还是贴两段代码，以下是 WXML 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;view class=&quot;shelf-nav&quot;&gt;</div><div class="line">&lt;view class=&quot;shelf-nav-item&quot;</div><div class="line">wx:for=&quot;&#123;&#123; shelfNavList &#125;&#125;&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../list/list?id=&#123;&#123; item.id &#125;&#125;&quot;&gt;</div><div class="line">&lt;image src=&quot;&#123;&#123; item.cover_image &#125;&#125;&quot;</div><div class="line">class=&quot;shelf-nav-item__image&quot;&gt; &lt;/image&gt;</div><div class="line">&lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>然后 WXSS 的代码如下，在关键代码处已经给出简要注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*** index.wxss ***/</div><div class="line">.shelf-nav &#123;</div><div class="line">display: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素</div><div class="line">flex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示</div><div class="line">padding: 30rpx;</div><div class="line">&#125;</div><div class="line">.shelf-nav-item &#123;</div><div class="line">width: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;</div><div class="line">margin-bottom: 20rpx;</div><div class="line">text-align: center; //让它中间的图片和标题居中显示</div><div class="line">&#125;</div><div class="line">.shelf-nav-item__image &#123;</div><div class="line">width: 130rpx; //在视觉稿中量取图片宽高为 130px</div><div class="line">height: 130rpx; //于是设置 width 和 height 都设置为 130rpx;</div><div class="line">border-radius: 50%; //把图片设置成圆形</div><div class="line">border: 1px solid #d9d9d9; //加上外边框</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。<br><br>第二个例子：效果图如下：<br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public" alt=""><br></div><br><br>如上图所示， 需要做到的效果是标题居左，「查看更多」（即…）的图标居右并且垂直居中。<br>代码结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;view class=&quot;shelf-header&quot;&gt;</div><div class="line">&lt;view class=&quot;shelf-title&quot;&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;shelf-title-en&quot;&gt;&#123;&#123; shelf.english_name &#125;&#125;&lt;/</div><div class="line">text&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;shelf-title-cn&quot;&gt;&#123;&#123; shelf.name &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view class=&quot;shelf-more&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../list/list?id=&#123;&#123; shelf.id &#125;&#125;&quot;</div><div class="line">class=&quot;ifanrin-more-icon ifanrin&quot;&gt; &lt;/navigator&gt;&lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>有经验的同学一眼就可以看出，要实现需求需要：<br>1/让 .shelf-title 向左浮动<br>2/让 .shelf-more 水平方向右对齐、垂直方向居中<br>3/最后还要给 .shelf-header clearfix 一下<br>那现在来看看 Flex 是怎么做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*** index.wxss ***/</div><div class="line">.shelf-header &#123;</div><div class="line">display: flex; //设置为 flex 布局的元素</div><div class="line">justify-content: space-between; //均匀排列每个元</div><div class="line">素，首、末两元素分别位于起点和终点</div><div class="line">&#125;</div><div class="line">.shelf-more &#123;</div><div class="line">align-self: center; //设置居中</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>只要区区几行代码，就能轻松使用 Flex 调整排版。<br>接下来，发起一个请求获取数据，然后setData() 绑定数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*** index.js ***/</div><div class="line">Page()&#123;</div><div class="line">...,</div><div class="line">onLoad: function () &#123;</div><div class="line">var that = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.SHELF_QUERY,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,success: function (res) &#123;</div><div class="line">that.setData(&#123;</div><div class="line">shelfNavList: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>此时列表页就基本完成了。<br><br>#### 4、template模板的使用<br>效果图如下：<br><br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg" alt=""><br></div><br><br>不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，<br>在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。<br><br><font color="red">1.定义 template 模板</font>

<p>为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;template name=&quot;productCard&quot;&gt;</div><div class="line">&lt;view class=&quot;product-card&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../detail/detail?id=&#123;&#123; id &#125;&#125;&quot;&gt;</div><div class="line">&lt;view style=&quot;background-image:</div><div class="line">url(&#123;&#123; cover_image &#125;&#125;)&quot; class=&quot;product-cover&quot;&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;product-title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;text class=&quot;product-price&quot;&gt;</div><div class="line">￥&#123;&#123; price &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。</p>
<p><font color="red">2.引入 template 模板</font><br>以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;import</div><div class="line">src=&quot;../../templates/productCard/productCard.wxml</div><div class="line">&quot; /&gt;</div><div class="line">&lt;view class=&quot;product-list&quot;&gt;</div><div class="line">&lt;block wx:for=&quot;&#123;&#123; productNewList &#125;&#125;&quot; &lt;template</div><div class="line">is=&quot;productCard&quot; data=&quot;&#123;&#123; ...item &#125;&#125;&quot; /&gt; &lt;/block&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">留意 data=&quot;&#123;&#123; ...item &#125;&#125; 的写法， item 是 wx:for 中代表数组当前项的默认变量名，</div><div class="line"> item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，</div><div class="line">  template 中 就 可 以 直 接 写 成 &#123;&#123; id &#125;&#125; ，&#123;&#123; cover_image &#125;&#125; ， 而 不 用 写 &#123;&#123; item.id &#125;&#125; ，</div><div class="line">  &#123;&#123; item.cover_image &#125;&#125;。它的意义在于实现了 template 与 wx:for-item 之间的解耦，</div><div class="line">  比如这里设置了 wx:for-item=&quot;product&quot;，我们只要设改变data=&quot;&#123;&#123; ...product &#125;&#125;&quot; 就可以了。</div><div class="line">如果数据没有通过解构，就要将 template 的 &#123;&#123; item.id &#125;&#125;修改成 &#123;&#123; product.id &#125;&#125;，很不方便。</div><div class="line">接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了</div></pre></td></tr></table></figure></p>
<h4 id="5-模板的-WXSS文件如何引入"><a href="#5-模板的-WXSS文件如何引入" class="headerlink" title="5.模板的 WXSS文件如何引入"></a>5.模板的 WXSS文件如何引入</h4><p>在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*** app.wxss ***/</div><div class="line">@import &quot;./templates/productCard/productCard.wxss&quot;;</div></pre></td></tr></table></figure></p>
<p>获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*** list.js ***/</div><div class="line">onLoad: function (options) &#123;</div><div class="line">var id = options.id;</div><div class="line">this.setData(&#123;</div><div class="line">shelfId: id</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*** list.js ***/</div><div class="line">onLoad: function (options) &#123;</div><div class="line">...</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.PRODUCT_LIST,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">shelf__id: this.data.shelfId</div><div class="line">&#125;,</div><div class="line">success: function (res) &#123;</div><div class="line">if (res.status == 200) &#123;</div><div class="line">that.setData(&#123;</div><div class="line">productNewList: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。</p>
<h2 id="数据加载和图文排版"><a href="#数据加载和图文排版" class="headerlink" title="数据加载和图文排版"></a>数据加载和图文排版</h2><h4 id="1-「查看更多」功能"><a href="#1-「查看更多」功能" class="headerlink" title="1.「查看更多」功能"></a>1.「查看更多」功能</h4><p>效果图如下：</p>
<div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public" alt=""><br></div>

<p>一、 调用 Toast 提示<br>通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">wx.showToast(&#123;</div><div class="line">title: &apos;成功&apos;, //提示的文字信息icon: &apos;success&apos;, //图标，只支持&quot;success&quot;、 &quot;loading&quot;</div><div class="line">duration: 2000, //提示的延迟时间(毫秒)，最大为 10000</div><div class="line">success: function() &#123;&#125;, //调用成功的回调函数</div><div class="line">fail: function() &#123;&#125;, //调用失败的回调函数</div><div class="line">//接口调用结束的回调函数（调用成功、失败都会执行）</div><div class="line">complete: function() &#123;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。</p>
<p>当然这会带来一些问题：<br>1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。<br>2.加载提示消失与数据成功加载之间出现时间差。<br>如何解决这个问题呢？其实不难！！！<br>先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。<br>我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。</p>
<p>若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？<br>那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">_setTimeoutFlag: function () &#123;</div><div class="line">var that = this;</div><div class="line">var timer = null;</div><div class="line">timer = setTimeout(function () &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;查看更多&apos;</div><div class="line">&#125;);</div><div class="line">timeoutFlag.timer = &#123; isTimeout: true &#125;;</div><div class="line">&#125;, 9800);</div><div class="line">timeoutFlag.timer = &#123; isTimeout: false &#125;;</div><div class="line">return timer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二、 构建与实现 loadMore 函数<br>我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：<br>1.第一次获取 20 条： limit=20 &amp; offset=0<br>2.第二次再新增 10 条： limit=10 0&amp; offset=20<br>3.第三次再新增 10 条： limit=10 &amp; offset=30<br>当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。</p>
<p>根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：<br>1.按钮文字变为「正在加载…」，页面弹出「加载中…」的loading 提示框，设置 offset + 10 并发起请求；<br>2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；<br>3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。<br>4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框</p>
<p>先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/***list.wxml***/</div><div class="line">&lt;view class=&quot;btn-load-more&quot; bindtap=&quot;loadMore&quot;&gt;</div><div class="line">&#123;&#123; tipText &#125;&#125;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">loadMore: function () &#123;var that = this;</div><div class="line">this.setData(&#123;</div><div class="line">tipText: &apos;正在加载...&apos;</div><div class="line">&#125;);</div><div class="line">wx.showToast(&#123;</div><div class="line">title: &apos;加载中...&apos;,</div><div class="line">icon: &apos;loading&apos;,</div><div class="line">duration: 10000</div><div class="line">&#125;);</div><div class="line">var timer = that._setTimeoutFlag();</div><div class="line">this._getMoreProductList(timer);</div><div class="line">&#125;,</div><div class="line">_getMoreProductList: function (timer) &#123;</div><div class="line">var that = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.PRODUCT_LIST +</div><div class="line">this.data.orderBy,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">limit: 10,</div><div class="line">offset: this.data.offset + 10,</div><div class="line">shelf__id: this.data.shelfId,</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,</div><div class="line">success: function (data) &#123;</div><div class="line">if (!timeoutFlag.timer.isTimeout) &#123;</div><div class="line">if (data.data.objects.length &gt; 1) &#123;</div><div class="line">var objects = that.data.productList</div><div class="line">.concat(data.data.objects);</div><div class="line">that.setData(&#123;</div><div class="line">productList: objects,</div><div class="line">offset: that.data.offset + 10,</div><div class="line">tipText: &apos;查看更多&apos;&#125;);</div><div class="line">&#125; else &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;没有更多啦&apos;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">clearTimeout(timer);</div><div class="line">wx.hideToast();</div><div class="line">&#125;,</div><div class="line">fail: function () &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;查看更多&apos;</div><div class="line">&#125;);</div><div class="line">wx.hideToast();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.</p>
<h4 id="2-商品详情页与图文排版实现"><a href="#2-商品详情页与图文排版实现" class="headerlink" title="2.商品详情页与图文排版实现"></a>2.商品详情页与图文排版实现</h4><p>效果图如下：</p>
<p><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png" alt=""><br></div><br>目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。<br>现在有两种思路去解决这个问题：<br>1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；<br>2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。<br>这里选用的是第二种方案，获取到的 JSON 数据格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;description&quot;: [</div><div class="line">&#123;</div><div class="line">&quot;content&quot;: &quot;xxx.jpg&quot;,</div><div class="line">&quot;type&quot;: &quot;image&quot;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">&quot;content&quot;: &quot;商品᧿述文字&quot;,</div><div class="line">&quot;type&quot;: &quot;text&quot;</div><div class="line">&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/***detail.wxml***/</div><div class="line">&lt;block wx:for=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;</div><div class="line">&lt;view</div><div class="line">class=&quot;description-img&quot;</div><div class="line">wx:if=&quot;&#123;&#123; item.type == &apos;image&apos; &#125;&#125;&quot;&gt;</div><div class="line">&lt;image</div><div class="line">class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;&gt;</div><div class="line">&lt;/image&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view</div><div class="line">class=&quot;description-text&quot;</div><div class="line">wx:elif=&quot;&#123;&#123; item.type == &apos;text&apos; &#125;&#125;&quot;&gt;</div><div class="line">&lt;text class=&quot;description-text-content&quot;&gt;</div><div class="line">&#123;&#123; item.content &#125;&#125;</div><div class="line">&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/block&gt;</div></pre></td></tr></table></figure></p>
<p>仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:’ 图 片 高 度 px’,width:’图片宽度 px’} 的方式调整图片宽高尺寸。<br>我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;image</div><div class="line">class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;</div><div class="line">bindload=&quot;imageLoad&quot;</div><div class="line">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;&gt;</div><div class="line">&lt;/image&gt;</div><div class="line">detail.js 定义 imageLoad 函数如下：</div><div class="line">data: &#123;</div><div class="line">images: &#123;&#125;</div><div class="line">&#125;,</div><div class="line">imageLoad: function (e) &#123;</div><div class="line">var realityWidth = e.detail.width; //获取图片实际宽度</div><div class="line">var realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例</div><div class="line">var proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;</div><div class="line">//父元素的左右 padding 都是 40rpx</div><div class="line">var viewWidth = 670;//按比例计算出图片的渲染高度</div><div class="line">var viewHeight = 670 / proportion;</div><div class="line">var images = this.data.images;//将图片的 data-index 值作为 images 对象的 key</div><div class="line">//用来储存该图片的计算后的渲染宽高</div><div class="line">images[e.currentTarget.dataset.index] = &#123;</div><div class="line">width: viewWidth,</div><div class="line">height: viewHeight</div><div class="line">&#125;;</div><div class="line">this.setData(&#123;</div><div class="line">images: images</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。<br>detail.wxml 改写 image 组件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;image class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot; bindload=&quot;imageLoad&quot;</div><div class="line">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;</div><div class="line">style=&quot;width:&#123;&#123; images[index].width &#125;&#125;rpx;</div><div class="line">height:&#123;&#123; images[index].height &#125;&#125;rpx&quot;&gt;</div><div class="line">&lt;/image&gt;</div></pre></td></tr></table></figure></p>
<p>此时在预览页面时，你会发现图片等就会正常显示了。</p>
<h4 id="内容总结提示"><a href="#内容总结提示" class="headerlink" title="内容总结提示"></a>内容总结提示</h4><ul>
<li><p>Toast 提示：<br>1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。<br>2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。</p>
</li>
<li><p>图文排版：<br>1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。<br>2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxapp1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxapp1/" class="article-date">
      <time datetime="2017-02-06T07:43:11.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxapp1/">微信小程序之开发文档解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="页面构建"><a href="#页面构建" class="headerlink" title="页面构建"></a>页面构建</h2><h4 id="1-基本逻辑"><a href="#1-基本逻辑" class="headerlink" title="1. 基本逻辑"></a>1. 基本逻辑</h4><p>WXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。<br>view 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。</p>
<p>小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或<br>scroll-x（左右滚动）为 true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;scroll-view scroll-y=&quot;true&quot;&gt;</div><div class="line">    &lt;view&gt;Hello World&lt;/view&gt;</div><div class="line">&lt;/scroll-view&gt;</div></pre></td></tr></table></figure></p>
<p>小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex<br>布局，它是 W3C 在 2009 年提出的一种排版标准。</p>
<h4 id="2-绑定数据"><a href="#2-绑定数据" class="headerlink" title="2. 绑定数据"></a>2. 绑定数据</h4><p>对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。</p>
<h4 id="3-条件渲染与列表（循环）渲染"><a href="#3-条件渲染与列表（循环）渲染" class="headerlink" title="3. 条件渲染与列表（循环）渲染"></a>3. 条件渲染与列表（循环）渲染</h4><p>条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:if=&quot;&#123;&#123; boyname == &apos;Tom&apos; &#125;&#125;&quot;&gt;Hello,</div><div class="line">Tom!&lt;/view&gt;</div><div class="line">&lt;view wx:elif=&quot;&#123;&#123; girlname == &apos;Anna&apos; &#125;&#125;&quot;&gt;Hello,</div><div class="line">Anna!&lt;/view&gt;</div><div class="line">&lt;view wx:else&gt;You neither Tom nor Anna.&lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">boyname: &apos;Tom&apos;,</div><div class="line">girlname: &apos;Anna&apos;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</div><div class="line">&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</div><div class="line">&lt;/view&gt;</div><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">array: [&#123;</div><div class="line">message: &apos;foo&apos;,</div><div class="line">&#125;, &#123;</div><div class="line">message: &apos;bar&apos;</div><div class="line">&#125;]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染完毕后，渲染判断条件的变动可以影响界面变动。</p>
<h4 id="4-模板与引用"><a href="#4-模板与引用" class="headerlink" title="4. 模板与引用"></a>4. 模板与引用</h4><p>WXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template name=&quot;grettings&quot;&gt;</div><div class="line">&lt;view&gt;</div><div class="line">&lt;text&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/template&gt;//some other codes</div><div class="line">&lt;template is=&quot;grettings&quot; data=&quot;&#123;&#123;...name&#125;&#125;&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>如果需要整个页面引用，需要使用到 include。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;include src=&quot;header.wxml&quot;/&gt;</div><div class="line">&lt;view&gt; body &lt;/view&gt;</div><div class="line">&lt;include src=&quot;footer.wxml&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="5-样式"><a href="#5-样式" class="headerlink" title="5. 样式"></a>5. 样式</h4><p>通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进<br>行样式定义。</p>
<h4 id="6-用户操作与事件响应"><a href="#6-用户操作与事件响应" class="headerlink" title="6. 用户操作与事件响应"></a>6. 用户操作与事件响应</h4><p>由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;view bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">tapName: function(someThingHere)&#123;</div><div class="line">// 执行这部分代码</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tapName: function() &#123;</div><div class="line">wx.navigateTo(&#123;</div><div class="line">url: &apos;../logs/logs&apos;</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。</p>
<h2 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a>网络访问</h2><p>小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。</p>
<h2 id="多媒体与存储"><a href="#多媒体与存储" class="headerlink" title="多媒体与存储"></a>多媒体与存储</h2><p>若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。<br>有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。</p>
<h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><p>小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。<br>1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）<br>2.重力感应数据<br>3.罗盘数据<br>通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。</p>
<h2 id="推送服务"><a href="#推送服务" class="headerlink" title="推送服务"></a>推送服务</h2><p>小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。</p>
<h2 id="用户信息与微信支付"><a href="#用户信息与微信支付" class="headerlink" title="用户信息与微信支付"></a>用户信息与微信支付</h2><p>小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。</p>
<p>如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxappintroduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxappintroduction/" class="article-date">
      <time datetime="2017-02-06T02:38:24.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxappintroduction/">微信小程序简单介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。</p>
<h4 id="对比一下小程序开发语言和「前端三件套」有什么异同点："><a href="#对比一下小程序开发语言和「前端三件套」有什么异同点：" class="headerlink" title="对比一下小程序开发语言和「前端三件套」有什么异同点："></a>对比一下小程序开发语言和「前端三件套」有什么异同点：</h4><p>一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界<br>面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。<br>二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。<br>三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。</p>
<p>小程序开发需要学习的语言主要有：</p>
<ol>
<li>微信标记语言  （weixin marked language,   wxml）</li>
<li>微信样式表（weixin style sheet, wxss ）</li>
<li>javascript</li>
</ol>
<p>小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的<code>&lt;div&gt;、&lt;a&gt;</code>等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。</p>
<p>小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。</p>
<h4 id="为什么需要动态单位和-rpx？"><a href="#为什么需要动态单位和-rpx？" class="headerlink" title="为什么需要动态单位和 rpx？"></a>为什么需要动态单位和 rpx？</h4><p>我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。<br>在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。</p>
<p>在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。</p>
<p>但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。</p>
<font color="red" face="“黑体”">苹果和 Google 对此都有相应的措施：</font>

<p>1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。<br>2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。</p>
<p>微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。</p>
<font color="red">Pixel与rpx、dp之间的换算</font>

<p>动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。<br>例如，dp 与 px 换算公式是：dp = px <em> (目标设备 dpi 分辨率 / 160)。<br>但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px </em> (目标设备宽 px 值 / 750)。</p>
<font color="red" face="“黑体”">例如：</font>

<p>目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px<br>目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px</p>
<p>没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。</p>
<font color="red" face="“黑体”">那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>

<p>dp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。</p>
<h4 id="设计师该怎么做？"><a href="#设计师该怎么做？" class="headerlink" title="设计师该怎么做？"></a>设计师该怎么做？</h4><p>由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。</p>
<p>那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？</p>
<p>在微信官方的文档中，我们看到下面这样一句话：</p>
<p>在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。</p>
<p>开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。<br>也就是说，设计师在设计小程序时，可以这样做：<br>直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；<br>以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。<br>在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-codetest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/05/codetest/" class="article-date">
      <time datetime="2017-02-05T02:43:12.000Z" itemprop="datePublished">2017-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/05/codetest/">使用Benchmark.js和jsPerf分析代码性能</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。</p>
<p>比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。</p>
<h4 id="Benchmark-js-的使用"><a href="#Benchmark-js-的使用" class="headerlink" title="Benchmark.js 的使用"></a>Benchmark.js 的使用</h4><p>其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：<br>首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。<br>将如下代码写入test.js文件，该文件置于系统根目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Benchmark = require(&apos;benchmark&apos;);</div><div class="line">var suite = new Benchmark.Suite;</div><div class="line"></div><div class="line">// 添加测试</div><div class="line">suite.add(&apos;RegExp#test&apos;, function() &#123;</div><div class="line">    /o/.test(&apos;Hello World!&apos;);</div><div class="line">&#125;)</div><div class="line">    .add(&apos;String#indexOf&apos;, function() &#123;</div><div class="line">        &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</div><div class="line">    &#125;)</div><div class="line">// add listeners</div><div class="line">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class="line">        console.log(String(event.target));</div><div class="line">    &#125;)</div><div class="line">    .on(&apos;complete&apos;, function() &#123;</div><div class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class="line">    &#125;)</div><div class="line">// run async</div><div class="line">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>
<p>然后在控制台执行node test.js 可见输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ git:(master) ✗ node test.js</div><div class="line">RegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)</div><div class="line">String#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)</div><div class="line">Fastest is String#indexOf</div></pre></td></tr></table></figure></p>
<p>结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;</p>
<p><font color="red">call和apply的比较</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var Benchmark = require(&apos;benchmark&apos;);</div><div class="line">var suite = new Benchmark.Suite;</div><div class="line">var arr1 = function (str) &#123;</div><div class="line">    return [].slice.apply(str);</div><div class="line">&#125;;</div><div class="line">var str2 = function (str) &#123;</div><div class="line">    return [].slice.call(str);</div><div class="line">&#125;;</div><div class="line">// 添加测试</div><div class="line">suite.add(&apos;arr1&apos;, function() &#123;</div><div class="line">    arr1(&apos;test&apos;);</div><div class="line">&#125;)</div><div class="line">    .add(&apos;str2&apos;, function() &#123;</div><div class="line">        str2(&apos;test&apos;);</div><div class="line">    &#125;)</div><div class="line">// add listeners</div><div class="line">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class="line">        console.log(String(event.target));</div><div class="line">    &#125;)</div><div class="line">    .on(&apos;complete&apos;, function() &#123;</div><div class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class="line">    &#125;)</div><div class="line">// run async</div><div class="line">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>
<p>输出如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)</div><div class="line">str2 x 627,822 ops/sec ±1.27% (92 runs sampled)</div><div class="line">Fastest is str2</div></pre></td></tr></table></figure></p>
<p><font color="red">本地的使用</font><br>本地使用Benchmark需要引入如下三个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h4 id="jsPerf-的使用"><a href="#jsPerf-的使用" class="headerlink" title="jsPerf 的使用"></a>jsPerf 的使用</h4><p>jsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。<br>打开jsPerf站点：<a href="http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code" target="_blank" rel="external">http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code</a> snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.<br>Async选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。</p>
<p><font color="red">运行测试</font><br>点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.<br>jsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。</p>
<p><font color="red">查看别人的测试用例</font><br>我们可以通过 <a href="http://jsperf.com/browse" target="_blank" rel="external">http://jsperf.com/browse</a> 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>John Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Benchmark-jsPerf/">Benchmark jsPerf</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-performancetest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/05/performancetest/" class="article-date">
      <time datetime="2017-02-05T01:37:46.000Z" itemprop="datePublished">2017-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/05/performancetest/">性能测试与调优</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var start = (new Date()).getTime(); // 或者Date.now()</div><div class="line">// 进行一些操作</div><div class="line">var end = (new Date()).getTime();</div><div class="line">console.log( &quot;Duration:&quot;, (end - start) );</div></pre></td></tr></table></figure></p>
<p>上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。<br>如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！</p>
<p>还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。</p>
<p>如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。</p>
<p>更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。</p>
<p><font color="red">重复</font><br>“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。</p>
<p><font color="red">Benchmark.js</font><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：<a href="http://benchmarkjs.com/" target="_blank" rel="external">http://benchmarkjs.com/</a><br>Benchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。<br>为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">// 要测试的运算</div><div class="line">&#125; v</div><div class="line">ar bench = new Benchmark(</div><div class="line">&quot;foo test&quot;, // 测试名称</div><div class="line">foo, // 要测试的函数（也即内容）</div><div class="line">&#123;</div><div class="line">// .. // 可选的额外选项（参见文档）</div><div class="line">&#125;</div><div class="line">);</div><div class="line">bench.hz; // 每秒运算数</div><div class="line">bench.stats.moe; // 出错边界</div><div class="line">bench.stats.variance; // 样本方差</div></pre></td></tr></table></figure></p>
<p>在上面的代码片段中， 其实忽略了“额外选项”<code>{ .. }</code> 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。<br>提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。</p>
<h4 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h4><p>尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。</p>
<p>比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。</p>
<p>有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（<a href="http://jsperf.com）" target="_blank" rel="external">http://jsperf.com）</a> 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。</p>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>ES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。<br>简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。<br>以下是一个非递归的尾调用的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">return x;</div><div class="line">&#125; f</div><div class="line">unction bar(y) &#123;</div><div class="line">return foo( y + 1 ); // 尾调用</div><div class="line">&#125;function baz() &#123;</div><div class="line">return 1 + bar( 40 ); // 非尾调用</div><div class="line">&#125; b</div><div class="line">az(); // 42</div></pre></td></tr></table></figure></p>
<p>foo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。<br>调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。<br>然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。<br>ES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-性能调试-Benchmark-jsPerf/">js 性能调试 Benchmark jsPerf</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Wenxi Yan
            </div>
            <div class="footer-right">
                <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >用户到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>