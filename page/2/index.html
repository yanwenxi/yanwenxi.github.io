<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人博客">
<meta property="og:url" content="http://yanwenxi.github.io/page/2/index.html">
<meta property="og:site_name" content="闫文喜的个人博客">
<meta property="og:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人博客">
<meta name="twitter:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Wenxi Yan</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">我的小窝</a></li>
                        
                            <li><a href="/archives">文章列表</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                            
                                <a class="fl wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-前端开发/" style="font-size: 10px;">css 前端开发</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css3/" style="font-size: 10px;">flex css3</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/i18n/" style="font-size: 10px;">i18n</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试-Benchmark-jsPerf/" style="font-size: 10px;">js 性能调试 Benchmark jsPerf</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/js继承、原型链/" style="font-size: 10px;">js继承、原型链</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/nginx/" style="font-size: 12.5px;">nginx</a> <a href="/tags/node/" style="font-size: 12.5px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 20px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 17.5px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 20px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/vue、mvvm/" style="font-size: 10px;">vue、mvvm</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 15px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端工程-构建工具-前端开发/" style="font-size: 10px;">前端工程 构建工具 前端开发</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com">前端小站</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://ywxi.github.io/">web博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">运动健身、网络营销、web前端、喜欢接触新鲜事物、迎接新的挑战</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Wenxi Yan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Wenxi Yan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">我的小窝</a></li>
                
                    <li><a href="/archives">文章列表</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-deepthis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/07/deepthis/" class="article-date">
      <time datetime="2017-02-07T02:43:40.000Z" itemprop="datePublished">2017-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/07/deepthis/">关于this那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="this的简单理解"><a href="#this的简单理解" class="headerlink" title="this的简单理解"></a>this的简单理解</h4><p>this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call()、apply()和bind()用来改变this关键字的</div><div class="line">function.call(thisObj,参数1，参数2....)</div><div class="line">function.apply(thisObj,[参数1，参数2....])</div><div class="line">function.bind(thisObj，参数1,参数2...)</div></pre></td></tr></table></figure></p>
<p>call和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line"> this.count++;</div><div class="line">&#125; </div><div class="line">foo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。</div><div class="line">foo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。</div><div class="line">foo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;</div></pre></td></tr></table></figure></p>
<p>总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p>
<h4 id="严格与非严格模式下的this"><a href="#严格与非严格模式下的this" class="headerlink" title="严格与非严格模式下的this"></a>严格与非严格模式下的this</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // 2，此时函数里的this默认指向全局window。</div></pre></td></tr></table></figure>
<p>如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>
<p>虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">(function()&#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">foo(); // 2</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">a: 42,</div><div class="line">foo: foo</div><div class="line">&#125;;</div><div class="line">var obj1 = &#123;</div><div class="line">a: 2,</div><div class="line">obj2: obj2</div><div class="line">&#125;;</div><div class="line">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>
<p>函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.<br>当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。</p>
<p>注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则<br>this 会被绑定到全局对象。</p>
<h4 id="判断this的规则"><a href="#判断this的规则" class="headerlink" title="判断this的规则"></a>判断this的规则</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</p>
<ul>
<li>1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。</li>
<li>2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</li>
<li>3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</li>
<li>4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()</li>
<li>5.定时器中的this一直指向window.</li>
</ul>
<h4 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125; v</div><div class="line">ar a = 2;</div><div class="line">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>
<p>那么什么情况下会传入 null 呢？<br>一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 把数组“ 展开” 成参数</div><div class="line">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( null, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。<br>小提示：在 ES6 中， 可以用 … 操作符代替 apply(..) 来“ 展开” 数组， foo(…[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。</p>
<p>然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览<br>器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。</p>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h4><p>一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。<br>在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 定义的 DMZ 空对象</div><div class="line">var ø = Object.create( null );//ø为变量名，可以随便起。</div><div class="line">// 把数组展开成参数</div><div class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( ø, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。</p>
<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h4><p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 =&gt; 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">// 返回一个箭头函数</div><div class="line">return (a) =&gt; &#123;</div><div class="line">//this 继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">var obj2 = &#123;</div><div class="line">a:3</div><div class="line">&#125;;</div><div class="line">var bar = foo.call( obj1 );</div><div class="line">bar.call( obj2 ); // 2, 不是 3 ！</div></pre></td></tr></table></figure></p>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不<br>行！ ）<br>箭头函数最常用于回调函数中， 例如事件处理器或者定时器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">// 这里的 this 在此法上继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;,100);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-this/">js this</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-deepclosure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/deepclosure/" class="article-date">
      <time datetime="2017-02-06T09:32:12.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/deepclosure/">深入理解闭包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">bar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a</div><div class="line">&#125; </div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125;</div><div class="line">return bar;</div><div class="line">&#125;</div><div class="line">var baz = foo();</div><div class="line">baz(); // 2 —— 这才是闭包</div></pre></td></tr></table></figure></p>
<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</p>
<p> 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。<br> 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125; </div><div class="line">bar( baz );</div><div class="line">&#125;</div><div class="line">function bar(fn) &#123;</div><div class="line">fn(); // 快看呀， 这就是闭包！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var fn;</div><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125; </div><div class="line">fn = baz; // 将 baz 分配给全局变量</div><div class="line">&#125;</div><div class="line">function bar() &#123;</div><div class="line">fn(); // 妈妈快看呀， 这就是闭包！</div><div class="line">&#125; </div><div class="line">foo();</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure></p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。</p>
<h4 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）</p>
<p>正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function() &#123;</div><div class="line">var j = i;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以对上面代码进行一些改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function(j) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<font color="red">也可以用块作用域来实现</font>

<p>使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">let j = i; // 是的， 闭包的块作用域！</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-closure/">js closure</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxapp-online" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxapp-online/" class="article-date">
      <time datetime="2017-02-06T08:07:17.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxapp-online/">简易电商类小程序开发教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>电商类平台主要由首页、分类页、商品列表页、商品详情页、购物车、订单结算页和个人中心等几大模块组成。<br>在开发过程中，也会穿插介绍一些常用简单内置组件的使用，最再后利用小程序的 template 模板，对自定义组件化开发的实现提供三种参考模式。</p>
<h4 id="1、准备开工"><a href="#1、准备开工" class="headerlink" title="1、准备开工"></a>1、准备开工</h4><p>先新建一个文件夹 wxapponline 作为项目目录，里面包含：<br>   1.common 目录——用来放置项目公用的文件<br>   2.pages 目录——项目页面开发目录，里面的每个子目录代表一 个 独 立 页 面 ， 分 别 包 含 与 目 录 同 名 的 .wxml （ 必须）， .wxss， .js（ 必须）和 .json 文件<br>   3.templates 目录——用来放置自定义的组件<br>   4.utils 目录——用来放置工具类 js 文件<br>   5.app.js——小程序逻辑<br>   6.app.json——小程序公共设置<br>   7.app.wxss——小程序公共样式表</p>
<h4 id="2、轮播banner样式定义"><a href="#2、轮播banner样式定义" class="headerlink" title="2、轮播banner样式定义"></a>2、轮播banner样式定义</h4><p>和大多数项目一样，最开始是首页的实现。<br>首 页 在 pages/index 目 录 下 ， 包 括 index.wxml 、index.wxss、 index.js 三个文件。</p>
<font color="red">实现 banner 轮播图，来看代码：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;swiper class=&quot;banner-swiper&quot;</div><div class="line">indicator-dots=&quot;&#123;&#123; indicatorDots &#125;&#125;&quot;</div><div class="line">autoplay=&quot;&#123;&#123; autoplay &#125;&#125;&quot; interval=&quot;&#123;&#123; interval &#125;&#125;&quot;</div><div class="line">duration=&quot;&#123;&#123; duration &#125;&#125;&quot;&gt;</div><div class="line">&lt;swiper-item class=&quot;swiper-item&quot;</div><div class="line">wx:for=&quot;&#123;&#123; banners &#125;&#125;&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../detail/detail?id=&#123;&#123; item.productId &#125;&#125;&quot;&gt;</div><div class="line">&lt;image src=&quot;&#123;&#123; item.image &#125;&#125;&quot;</div><div class="line">class=&quot;slide-image&quot;&gt;&lt;/image&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/swiper-item&gt;</div><div class="line">&lt;/swiper&gt;</div></pre></td></tr></table></figure><br><br>值得注意的是， image 组件会有一个默认的样式.可以到官方文档中去查找images组件的默认样式。默认宽高可能在不同的版本中有不同的值。我们可以根据实际情况给它重新定义一个宽高值。单位：rpx;<br>友情提：大多数小程序内置组件都会有自己的默认样式，我们可以利用开发工具中的wxml panel，多了解一下这些组件的默认样式，可以避免很多由组件默认样式引起的问题。<br>另一个注意点是，不要将大图片放到项目目录中，因为小程序代码总大小不能超过 1 MB，而大图片会占用大量的空间，所以要尽量避免在项目目录中放置大图片。<br>如有需要，建议只在项目目录中放置少量 icon 类的小图片，其他大图片可以上传到自己的服务器或者网盘中，然后在 src 中设置图片的网络资源地址。<br>在手机测试或者正式上线之前，要注意是否有引用了本地大图片导致代码超出大小限制的问题。<br><br>#### 3.准备获取 banner    数据，并绑定到视图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*** index.js ***/</div><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">banners: [], //初始化一个 banners 数组</div><div class="line">//以下四项设置 swiper 组件的参数值</div><div class="line">indicatorDots: true</div><div class="line">, autoplay: true, //开启自动切换</div><div class="line">interval: 5000, //自动切换时间间隔</div><div class="line">duration: 1000 //滑动动画时长&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br>在 Page 里的 data 会以 JSON 的形式由逻辑层传至视图层，然后在视图层中使用 Mustache 语法（双大括号）接收传入的数据，实现动态数据的数据绑定。经过绑定后的数据变动可以在视图中实时反应，也可以通过开发者工具中的 AppData Panel 中查看和编辑页面中的所有 data 数据。<br>友情提醒：当你不知道 data 数据是否被设置成功的时候，可以到 AppData Panel 来查看一下，免去了手动打 console.log 进行调试的麻烦。<br><br>实现动态数据绑定的另一个方式是使用 this.setData() 方法 ， this 在 这 里 代 表 的 是 Page ， 而 setData 是在PageX.prototype 中的方法，所以 this.setData() 实际上访问的是 Page.prototype.setData()。它可以用来新增和修改 this.data 里的值，同时还有一个重要的功能是将数据从逻辑层发送到视图层，从而实时改变页面的状态，保持逻辑层和视图层数据的一致性。需要注意的是，如果使用 this.data.property = value，同样可以设置 this.data 的值，但是它不会将数据发送到视图层，无法改变页面的状态。<br>注意： 一 定 要 避 免 使 用this.data.property = value 的方式设置数据。<br><br>#### 4.从服务器获取 banner数据<br>现在我们的目的是要得到一个 banners 数组，然后利 用 wx:for 将 banners 数 组 中 的 每 一 项 渲 染 到swiper-item 中。我们可以在页面加载（ onLoad） 时，使用 wx.request() 发<br>起一个 Ajax 请求，来获取到所需要的 banner 列表数据。先 来 看 一 下 wx.request(object) 的 使 用 方 法 。 首 先 是object 可以接受的参数值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. url：设置发送请求的地址。</div><div class="line">2. method：请求方式，默认为 GET，有效值： OPTIONS， GET，HEAD， POST， PUT， DELETE， TRACE， CONNECT。注意，所有值都要使用大写。 经过测试，若使用小写，在安卓中会导致无法发起请求，而在开发者工具和 iOS 中则正常。</div><div class="line">3. data：设置请求的参数。如果 method 值为 GET，这个函数会将 data 转换成 query 字符串，拼接在 url 后面，若 url 本身带有同名的 query 参数，那么 data 中的参数会覆盖 url 中的 query 参数；小 程 序 执 行 wx.request(object) 发 送 请 求 并 收 到success（成功）的消息后，会自动执行请求成功返回的回调函数。回调函数执行时，会自动收到类似这样的回调参数：</div><div class="line">res = &#123;data: &apos;服务器返回的数据&apos;, errMsg: &apos;错误信息&apos;, statusCode: HTTP 状态码&#125;</div></pre></td></tr></table></figure><br><br>特别注意，在开发者工具和 iOS 中， res.statusCode 的类据类型是一个数值， 而在 Android 中的数据类型是一个字符串，所以在判断 res.statusCode 时不能直接使用 === 操作符，而应该用 == 操作符，或者是先对 res.statusCode 进行数据类型转换。现在，就可以在 onLoad 中调用 wx.request() 发起请求，访问获取 banner 列表的服务器 API。<br>我们将各服务器 API 的访问地址都保存在 API_URL 对象，保存在 utils/config.js 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*** config.js ***/</div><div class="line">const CONFIG = &#123;</div><div class="line">API_URL: &#123;</div><div class="line">BANNER_QUERY: http://ifanr.com/api/banner</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">module.exports = CONFIG;</div><div class="line">然 后 需 要 在 index.js 中 使 用 require 引 入utils/config.js 文件，引入路径为当前文件的相对路径：</div><div class="line">/*** index.js ***/</div><div class="line">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class="line">于是，我们就知道了在小程序中 js 模块化的方法，模块通过module.exports 对外暴露接口，在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。发起 wx.request 请求：</div><div class="line">/*** index.js ***/</div><div class="line">var CONFIG = require(&apos;../../utils/config.js&apos;);</div><div class="line">Page(&#123;</div><div class="line">data: &#123;...</div><div class="line">&#125;,</div><div class="line">onLoad: function () &#123;</div><div class="line">var _this = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.BANNER_QUERY,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">limit: 6,</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,</div><div class="line">success: function (res) &#123;</div><div class="line">if (res.statusCode == 200) &#123;</div><div class="line">_this.setData(&#123;</div><div class="line">banners: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br><br>在 wx.request() 的回调函数中判断 res.statusCode 是否 为 200 ， 若 为 200 则 代 表 请 求 成 功 ， 接 着 将 数 据 保 存 到banners 数组中。我 们 在 success 回 调 函 数 中 使 用_this.setData({ banners: res.data.objects }); 设置banners 的值。<br>注意 ： 这 里 不 能 直 接 使 用this.setData() ，因为 success 回调函数是一个闭包，我们要先 在 闭 包 外 面 定 义 var _this = this; ， 再调用_this.setData()，以保证闭包内能到正确的 this 值。现在，在视图中我们就能看到完整的 banner 列表了。<br><br>## 如何做商品列表<br>#### 1.为布局而生的 Flex<br>传统的布局方式一般都是基于 div 盒子模型，利用 float，position， display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到CSS3 提出了专为布局而生的解决方案，就是 Flex 布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 Flex 布局直接应用到实际项目之中。在常规项目中，大量应用 Flex 布局还需要一个过程。<br><br>而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 Flex 引起的性能问题。我们可以放心地在小程序中使用 Flex 来处理布局。<br>#### 2.如何更方便地使用 rpx<br>rpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏<br>幕实际宽度的不同， 1rpx 所代表的实际像素值也不一样。<br><br>例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx =375px， 1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px， 1rpx = 0.42px。<br>其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。强烈建议用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。<br><br>简单一句话解释：量取多少就设置多少。<br><br>#### 3.Flex配合rpx的使用案例<br>现在，我们就在小程序中使用 Flex 和 rpx 进行布局，体验一下这种解决方案的便利。<br>第一个例子：货架列表效果图：<br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline2.jpg" alt=""><br></div><br><br>首先还是贴两段代码，以下是 WXML 的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;view class=&quot;shelf-nav&quot;&gt;</div><div class="line">&lt;view class=&quot;shelf-nav-item&quot;</div><div class="line">wx:for=&quot;&#123;&#123; shelfNavList &#125;&#125;&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../list/list?id=&#123;&#123; item.id &#125;&#125;&quot;&gt;</div><div class="line">&lt;image src=&quot;&#123;&#123; item.cover_image &#125;&#125;&quot;</div><div class="line">class=&quot;shelf-nav-item__image&quot;&gt; &lt;/image&gt;</div><div class="line">&lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>然后 WXSS 的代码如下，在关键代码处已经给出简要注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*** index.wxss ***/</div><div class="line">.shelf-nav &#123;</div><div class="line">display: flex; // 设 置 display: flex; 将 它 变 为flex 布局的元素</div><div class="line">flex-wrap: wrap; //当子元素总宽度超过父元素宽度时换行显示</div><div class="line">padding: 30rpx;</div><div class="line">&#125;</div><div class="line">.shelf-nav-item &#123;</div><div class="line">width: 25%; //因为每行显示 4 个货架，所以宽度设置为25%;</div><div class="line">margin-bottom: 20rpx;</div><div class="line">text-align: center; //让它中间的图片和标题居中显示</div><div class="line">&#125;</div><div class="line">.shelf-nav-item__image &#123;</div><div class="line">width: 130rpx; //在视觉稿中量取图片宽高为 130px</div><div class="line">height: 130rpx; //于是设置 width 和 height 都设置为 130rpx;</div><div class="line">border-radius: 50%; //把图片设置成圆形</div><div class="line">border: 1px solid #d9d9d9; //加上外边框</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>简单几步就完成了货架列表的布局， 并且完美兼容各种大小的设备屏幕。<br><br>第二个例子：效果图如下：<br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline3.png-public" alt=""><br></div><br><br>如上图所示， 需要做到的效果是标题居左，「查看更多」（即…）的图标居右并且垂直居中。<br>代码结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;view class=&quot;shelf-header&quot;&gt;</div><div class="line">&lt;view class=&quot;shelf-title&quot;&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;shelf-title-en&quot;&gt;&#123;&#123; shelf.english_name &#125;&#125;&lt;/</div><div class="line">text&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;shelf-title-cn&quot;&gt;&#123;&#123; shelf.name &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view class=&quot;shelf-more&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../list/list?id=&#123;&#123; shelf.id &#125;&#125;&quot;</div><div class="line">class=&quot;ifanrin-more-icon ifanrin&quot;&gt; &lt;/navigator&gt;&lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure><br><br>有经验的同学一眼就可以看出，要实现需求需要：<br>1/让 .shelf-title 向左浮动<br>2/让 .shelf-more 水平方向右对齐、垂直方向居中<br>3/最后还要给 .shelf-header clearfix 一下<br>那现在来看看 Flex 是怎么做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*** index.wxss ***/</div><div class="line">.shelf-header &#123;</div><div class="line">display: flex; //设置为 flex 布局的元素</div><div class="line">justify-content: space-between; //均匀排列每个元</div><div class="line">素，首、末两元素分别位于起点和终点</div><div class="line">&#125;</div><div class="line">.shelf-more &#123;</div><div class="line">align-self: center; //设置居中</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>只要区区几行代码，就能轻松使用 Flex 调整排版。<br>接下来，发起一个请求获取数据，然后setData() 绑定数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*** index.js ***/</div><div class="line">Page()&#123;</div><div class="line">...,</div><div class="line">onLoad: function () &#123;</div><div class="line">var that = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.SHELF_QUERY,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,success: function (res) &#123;</div><div class="line">that.setData(&#123;</div><div class="line">shelfNavList: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>此时列表页就基本完成了。<br><br>#### 4、template模板的使用<br>效果图如下：<br><br><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline1.jpg" alt=""><br></div><br><br>不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，<br>在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念， template 的主要功能更多的是在于定义一个 WXML 代码片段，然后在不同的地方调用。template 拥有自己的作用域， 而且只能使用 data 传入的数据。接下来看看template 到底如何使用。<br><br><font color="red">1.定义 template 模板</font>

<p>为了方便代码组织，我们在 templates 目录下，新建一个productCard 文 件 夹 ， 并 在 product-card 文 件 夹 下 新 建productCard.wxml 和 productCard.wxss 文件。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;template name=&quot;productCard&quot;&gt;</div><div class="line">&lt;view class=&quot;product-card&quot;&gt;</div><div class="line">&lt;navigator</div><div class="line">url=&quot;../detail/detail?id=&#123;&#123; id &#125;&#125;&quot;&gt;</div><div class="line">&lt;view style=&quot;background-image:</div><div class="line">url(&#123;&#123; cover_image &#125;&#125;)&quot; class=&quot;product-cover&quot;&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view&gt;</div><div class="line">&lt;text</div><div class="line">class=&quot;product-title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;text class=&quot;product-price&quot;&gt;</div><div class="line">￥&#123;&#123; price &#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/navigator&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>使用 name 属性，定义模板的名字，然后将代码片断保存在template 中。</p>
<p><font color="red">2.引入 template 模板</font><br>以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表， template为子项，使用 is 声明需要的使用的模板，用 data 传入数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*** index.wxml ***/</div><div class="line">&lt;import</div><div class="line">src=&quot;../../templates/productCard/productCard.wxml</div><div class="line">&quot; /&gt;</div><div class="line">&lt;view class=&quot;product-list&quot;&gt;</div><div class="line">&lt;block wx:for=&quot;&#123;&#123; productNewList &#125;&#125;&quot; &lt;template</div><div class="line">is=&quot;productCard&quot; data=&quot;&#123;&#123; ...item &#125;&#125;&quot; /&gt; &lt;/block&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">留意 data=&quot;&#123;&#123; ...item &#125;&#125; 的写法， item 是 wx:for 中代表数组当前项的默认变量名，</div><div class="line"> item 前面的 ... 操作符相当于ES6 中的展开运算符，可用于需要解构赋值的地方.通 过 解 构 ，</div><div class="line">  template 中 就 可 以 直 接 写 成 &#123;&#123; id &#125;&#125; ，&#123;&#123; cover_image &#125;&#125; ， 而 不 用 写 &#123;&#123; item.id &#125;&#125; ，</div><div class="line">  &#123;&#123; item.cover_image &#125;&#125;。它的意义在于实现了 template 与 wx:for-item 之间的解耦，</div><div class="line">  比如这里设置了 wx:for-item=&quot;product&quot;，我们只要设改变data=&quot;&#123;&#123; ...product &#125;&#125;&quot; 就可以了。</div><div class="line">如果数据没有通过解构，就要将 template 的 &#123;&#123; item.id &#125;&#125;修改成 &#123;&#123; product.id &#125;&#125;，很不方便。</div><div class="line">接着，是 productCard.wxss 的引入，先在 productCard写好样式，这里就不贴代码了</div></pre></td></tr></table></figure></p>
<h4 id="5-模板的-WXSS文件如何引入"><a href="#5-模板的-WXSS文件如何引入" class="headerlink" title="5.模板的 WXSS文件如何引入"></a>5.模板的 WXSS文件如何引入</h4><p>在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import 进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*** app.wxss ***/</div><div class="line">@import &quot;./templates/productCard/productCard.wxss&quot;;</div></pre></td></tr></table></figure></p>
<p>获取商品列表数据，渲染视图先通过 onLoad 的 options 取得 id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*** list.js ***/</div><div class="line">onLoad: function (options) &#123;</div><div class="line">var id = options.id;</div><div class="line">this.setData(&#123;</div><div class="line">shelfId: id</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最 后 ， 调 用 wx:request() 获 取 商 品 列 表 数 据 ， 通 过setData() 设置 productNewList，即可在视图层渲染出完整的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*** list.js ***/</div><div class="line">onLoad: function (options) &#123;</div><div class="line">...</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.PRODUCT_LIST,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">shelf__id: this.data.shelfId</div><div class="line">&#125;,</div><div class="line">success: function (res) &#123;</div><div class="line">if (res.status == 200) &#123;</div><div class="line">that.setData(&#123;</div><div class="line">productNewList: res.data.objects</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面首次加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。</p>
<h2 id="数据加载和图文排版"><a href="#数据加载和图文排版" class="headerlink" title="数据加载和图文排版"></a>数据加载和图文排版</h2><h4 id="1-「查看更多」功能"><a href="#1-「查看更多」功能" class="headerlink" title="1.「查看更多」功能"></a>1.「查看更多」功能</h4><p>效果图如下：</p>
<div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline4.png-public" alt=""><br></div>

<p>一、 调用 Toast 提示<br>通过调用 wx.showToast() ，可以实现上图中部的 Toast 提示（加载中）。微信提供的 Toast 组件有 success 和 loading 两种状态（旧版本的 loading 组件已经被废弃）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">wx.showToast(&#123;</div><div class="line">title: &apos;成功&apos;, //提示的文字信息icon: &apos;success&apos;, //图标，只支持&quot;success&quot;、 &quot;loading&quot;</div><div class="line">duration: 2000, //提示的延迟时间(毫秒)，最大为 10000</div><div class="line">success: function() &#123;&#125;, //调用成功的回调函数</div><div class="line">fail: function() &#123;&#125;, //调用失败的回调函数</div><div class="line">//接口调用结束的回调函数（调用成功、失败都会执行）</div><div class="line">complete: function() &#123;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>需要注意的是， 当 showToast 执行时，整个页面是不可点击的。所以，不用考虑用户意外触发多次「查看更多」的问题。调用 wx.hideToast() 即可隐藏 Toast 提示框。现 在 ， 我 们 来 思 考 一 个 问 题 。 上 面 说到 wx.showToast 的 duration 最大值为 10000 毫秒，也就意味着当请求时间大于 10 秒，若没有返回数据时， loading 提示框会自动消失。</p>
<p>当然这会带来一些问题：<br>1.「查看更多」按钮重新变回可点击状态，可能造成请求的重复提交。<br>2.加载提示消失与数据成功加载之间出现时间差。<br>如何解决这个问题呢？其实不难！！！<br>先给 loading 设置 10000 毫秒延迟时间，超过 10000 毫秒后，即使请求成功，也不保存任何数据。同时，将按钮文字改回「查看更多」即可。<br>我 们 初 始 化 一 个 timeoutFlag 的 对 象 ， 使 用 timer =setTimeout() 设 置 9800 毫 秒 延 时 。 9800 毫 秒 后 ，以 timer 为 key 设置一个对象 { isTimeout: true }，每次发起请求时都会有一个 timer 作为标识。</p>
<p>若请求成功时 timeoutFlag.timer 的值为 { isTimeout:true }，则不处理请求成功后的数据。为什么要设置 9800 毫秒而不是 10000 毫秒呢？<br>那是因为 setTimeout 的计时并不准确，我们给出 200 毫秒的提前量，以防止代码出错。下面就来封装一个 _setTimeoutFlag 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">_setTimeoutFlag: function () &#123;</div><div class="line">var that = this;</div><div class="line">var timer = null;</div><div class="line">timer = setTimeout(function () &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;查看更多&apos;</div><div class="line">&#125;);</div><div class="line">timeoutFlag.timer = &#123; isTimeout: true &#125;;</div><div class="line">&#125;, 9800);</div><div class="line">timeoutFlag.timer = &#123; isTimeout: false &#125;;</div><div class="line">return timer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二、 构建与实现 loadMore 函数<br>我们需要一个 loadMore 函数，来做到数据的分页查询。一般，都是通过设置两个查询参数来控制，分别是每次请求条数 limit 和每次请求起始数 offset（即从第几条获取数据）。以我们的需求为例：<br>1.第一次获取 20 条： limit=20 &amp; offset=0<br>2.第二次再新增 10 条： limit=10 0&amp; offset=20<br>3.第三次再新增 10 条： limit=10 &amp; offset=30<br>当然，根据各自不同的分页实现， limit 和 offset 的命名也不相同，我们只要了解原理即可。</p>
<p>根据以上逻辑，当用户点击「查看更多」按钮后，小程序在不同情况下应该给出相应的反应：<br>1.按钮文字变为「正在加载…」，页面弹出「加载中…」的loading 提示框，设置 offset + 10 并发起请求；<br>2.有新数据加载时，按钮文字变回「查看更多」，关闭 loading提示框，保存当前 offset；<br>3.无新数据加载时，按钮文字变为「没有更多啦」，关闭loading 提示框。<br>4.请求失败时，按钮文字变为「查看更多」，关闭 loading 提示框</p>
<p>先在 list.wxml 中设置按钮，并绑定点击事件 loadMore;。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/***list.wxml***/</div><div class="line">&lt;view class=&quot;btn-load-more&quot; bindtap=&quot;loadMore&quot;&gt;</div><div class="line">&#123;&#123; tipText &#125;&#125;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>根 据 上 面 的 流 程 ， 封 装 一下 _getProductList 和 loadMore 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/***list.js***/</div><div class="line">loadMore: function () &#123;var that = this;</div><div class="line">this.setData(&#123;</div><div class="line">tipText: &apos;正在加载...&apos;</div><div class="line">&#125;);</div><div class="line">wx.showToast(&#123;</div><div class="line">title: &apos;加载中...&apos;,</div><div class="line">icon: &apos;loading&apos;,</div><div class="line">duration: 10000</div><div class="line">&#125;);</div><div class="line">var timer = that._setTimeoutFlag();</div><div class="line">this._getMoreProductList(timer);</div><div class="line">&#125;,</div><div class="line">_getMoreProductList: function (timer) &#123;</div><div class="line">var that = this;</div><div class="line">wx.request(&#123;</div><div class="line">url: CONFIG.API_URL.PRODUCT_LIST +</div><div class="line">this.data.orderBy,</div><div class="line">method: &apos;GET&apos;,</div><div class="line">data: &#123;</div><div class="line">limit: 10,</div><div class="line">offset: this.data.offset + 10,</div><div class="line">shelf__id: this.data.shelfId,</div><div class="line">img_size: &apos;small&apos;</div><div class="line">&#125;,</div><div class="line">success: function (data) &#123;</div><div class="line">if (!timeoutFlag.timer.isTimeout) &#123;</div><div class="line">if (data.data.objects.length &gt; 1) &#123;</div><div class="line">var objects = that.data.productList</div><div class="line">.concat(data.data.objects);</div><div class="line">that.setData(&#123;</div><div class="line">productList: objects,</div><div class="line">offset: that.data.offset + 10,</div><div class="line">tipText: &apos;查看更多&apos;&#125;);</div><div class="line">&#125; else &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;没有更多啦&apos;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">clearTimeout(timer);</div><div class="line">wx.hideToast();</div><div class="line">&#125;,</div><div class="line">fail: function () &#123;</div><div class="line">that.setData(&#123;</div><div class="line">tipText: &apos;查看更多&apos;</div><div class="line">&#125;);</div><div class="line">wx.hideToast();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，已经完整实现了商品列表页的开发，接下来进入商品详情页.</p>
<h4 id="2-商品详情页与图文排版实现"><a href="#2-商品详情页与图文排版实现" class="headerlink" title="2.商品详情页与图文排版实现"></a>2.商品详情页与图文排版实现</h4><p>效果图如下：</p>
<p><div align="center"><br> <img src="http://oi28tswuq.bkt.clouddn.com/images/wxapponline5.png" alt=""><br></div><br>目前商品详情的图文介绍，一般都是通过后台的富文本编辑器来排版创建的，数据都是以 HTML 代码的形式保存下来，然后在页面上直接渲染出来。但是对于小程序来说， HTML形式的数据不能直接拿来使用，因为小程序根本不能解析 HTML 代码。此时，我们需要处理由富文本编辑器所创建的数据，将其转换为JSON 格式的数据，以便于在小程序里使用。<br>现在有两种思路去解决这个问题：<br>1.由前端去解析 HTML 格式的数据，用正则匹配 HTML 标签，然后转换成 JSON 数据；<br>2.交由后端去解析，同时新增一个专用的 API，返回解析过的 JSON数据。<br>这里选用的是第二种方案，获取到的 JSON 数据格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;description&quot;: [</div><div class="line">&#123;</div><div class="line">&quot;content&quot;: &quot;xxx.jpg&quot;,</div><div class="line">&quot;type&quot;: &quot;image&quot;</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">&quot;content&quot;: &quot;商品᧿述文字&quot;,</div><div class="line">&quot;type&quot;: &quot;text&quot;</div><div class="line">&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我 们 只 要 将 获 取 的 数 据 用 wx:for 渲 染 出 来 ， 渲 染 时 判断 type 选择对应的 text 或 image 组件即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/***detail.wxml***/</div><div class="line">&lt;block wx:for=&quot;&#123;&#123; description &#125;&#125;&quot;&gt;</div><div class="line">&lt;view</div><div class="line">class=&quot;description-img&quot;</div><div class="line">wx:if=&quot;&#123;&#123; item.type == &apos;image&apos; &#125;&#125;&quot;&gt;</div><div class="line">&lt;image</div><div class="line">class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;&gt;</div><div class="line">&lt;/image&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;view</div><div class="line">class=&quot;description-text&quot;</div><div class="line">wx:elif=&quot;&#123;&#123; item.type == &apos;text&apos; &#125;&#125;&quot;&gt;</div><div class="line">&lt;text class=&quot;description-text-content&quot;&gt;</div><div class="line">&#123;&#123; item.content &#125;&#125;</div><div class="line">&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/block&gt;</div></pre></td></tr></table></figure></p>
<p>仔细观察一下，可以发现，每一张图片的宽高都发生了不同程度的裁剪、拉伸或压缩。这是由于 image 组件的默认宽高导致的，这个问题在上面也说过，要特别留意小程序内置组件的默认样式，它们很可能会引起各种各样的问题。我们的期望是，图片能够按照原有的宽高比例进行显示，并且每一张图片的宽度都能撑满整个内容区域。这应该如何处理呢？这里就需要用到 image 组件的 load 事件，使用 bindload 属性将事件绑定在 image 组件中。我 们 可 以 用 event.detail = {height:’ 图 片 高 度 px’,width:’图片宽度 px’} 的方式调整图片宽高尺寸。<br>我们定义一个 imageLoad 函数，作为 image 组件的 load 事件的处理函数，用 data-index 保存当前 wx:for 的 index 值作当前图片的索引值。detail.wxml 改写 image 组件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;image</div><div class="line">class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot;</div><div class="line">bindload=&quot;imageLoad&quot;</div><div class="line">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;&gt;</div><div class="line">&lt;/image&gt;</div><div class="line">detail.js 定义 imageLoad 函数如下：</div><div class="line">data: &#123;</div><div class="line">images: &#123;&#125;</div><div class="line">&#125;,</div><div class="line">imageLoad: function (e) &#123;</div><div class="line">var realityWidth = e.detail.width; //获取图片实际宽度</div><div class="line">var realityHeight = e.detail.height; //获取图片实际高度//获取图片的实际宽高比例</div><div class="line">var proportion = realityWidth / realityHeight;//设置图片的渲染宽度， 750rpx - (2 * 40rpx) = 670rpx;</div><div class="line">//父元素的左右 padding 都是 40rpx</div><div class="line">var viewWidth = 670;//按比例计算出图片的渲染高度</div><div class="line">var viewHeight = 670 / proportion;</div><div class="line">var images = this.data.images;//将图片的 data-index 值作为 images 对象的 key</div><div class="line">//用来储存该图片的计算后的渲染宽高</div><div class="line">images[e.currentTarget.dataset.index] = &#123;</div><div class="line">width: viewWidth,</div><div class="line">height: viewHeight</div><div class="line">&#125;;</div><div class="line">this.setData(&#123;</div><div class="line">images: images</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此 时 ，就 可 以 在 image 组 件 中 获 取到 images[index].width 和 images[index].height，并通过设置行内的 style 给每一个图片设置宽高了。<br>detail.wxml 改写 image 组件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;image class=&quot;description-img-content&quot;</div><div class="line">src=&quot;&#123;&#123; item.content &#125;&#125;&quot; bindload=&quot;imageLoad&quot;</div><div class="line">data-index=&quot;&#123;&#123; index &#125;&#125;&quot;</div><div class="line">style=&quot;width:&#123;&#123; images[index].width &#125;&#125;rpx;</div><div class="line">height:&#123;&#123; images[index].height &#125;&#125;rpx&quot;&gt;</div><div class="line">&lt;/image&gt;</div></pre></td></tr></table></figure></p>
<p>此时在预览页面时，你会发现图片等就会正常显示了。</p>
<h4 id="内容总结提示"><a href="#内容总结提示" class="headerlink" title="内容总结提示"></a>内容总结提示</h4><ul>
<li><p>Toast 提示：<br>1.Toast 提 示 可 以 使 用 wx.showToast() 来 调 用 ， 使用 wx.hideToast() 隐藏。l 开发者可以自定义 Toast 展示时间、展示文案等。<br>2.Toast 最长展示时间不能超过 10000 毫秒，开发者需要做好超时处理工作。</p>
</li>
<li><p>图文排版：<br>1.如果服务器中的数据是 HTML 数据，需要转换为 JSON，小程序才能解析。<br>2.直接将图片进行排版，图片宽高会出现问题。开发者需要处理好图片的宽高问题。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxapp1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxapp1/" class="article-date">
      <time datetime="2017-02-06T07:43:11.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxapp1/">微信小程序之开发文档解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="页面构建"><a href="#页面构建" class="headerlink" title="页面构建"></a>页面构建</h2><h4 id="1-基本逻辑"><a href="#1-基本逻辑" class="headerlink" title="1. 基本逻辑"></a>1. 基本逻辑</h4><p>WXML 和 WXSS 两种文件是小程序界面元素声明及样式描述文件。 WXML 最大的特点是以视图（ view）的方式串联界面元素，并通过程序逻辑（ AppService），将信息更新实时传递至视图层。<br>view 类似于 HTML 中的 div 元素。在构建的时候， view 可以被多级嵌套， view 内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户是无法再看到的，这与 HTML 有较大不同。举一个例子，将手机屏幕想像成一个舞台，在舞台之外的演员是无法被观众看到的。</p>
<p>小程序有专门用于滚动的视图，如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用 scroll-view 视图，在 WXSS中将其大小调整为整个屏幕，并设置 scroll-y（上下滚动）或<br>scroll-x（左右滚动）为 true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;scroll-view scroll-y=&quot;true&quot;&gt;</div><div class="line">    &lt;view&gt;Hello World&lt;/view&gt;</div><div class="line">&lt;/scroll-view&gt;</div></pre></td></tr></table></figure></p>
<p>小程序中不能直接使用 DOM 控制 WXML 元素。如果需要进行数据更新，需要使用 WXML 提供的数据绑定及元素渲染方法。还有一点需要注意的是：小程序的栅格排版系统使用的是 Flex<br>布局，它是 W3C 在 2009 年提出的一种排版标准。</p>
<h4 id="2-绑定数据"><a href="#2-绑定数据" class="headerlink" title="2. 绑定数据"></a>2. 绑定数据</h4><p>对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在 JS 主程序中以函数形式进行更新，更新同样可以反映到界面上被绑定的数据中。</p>
<h4 id="3-条件渲染与列表（循环）渲染"><a href="#3-条件渲染与列表（循环）渲染" class="headerlink" title="3. 条件渲染与列表（循环）渲染"></a>3. 条件渲染与列表（循环）渲染</h4><p>条件渲染适合带有意外情况提示的页面（如无法加载列表或详情时做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:if=&quot;&#123;&#123; boyname == &apos;Tom&apos; &#125;&#125;&quot;&gt;Hello,</div><div class="line">Tom!&lt;/view&gt;</div><div class="line">&lt;view wx:elif=&quot;&#123;&#123; girlname == &apos;Anna&apos; &#125;&#125;&quot;&gt;Hello,</div><div class="line">Anna!&lt;/view&gt;</div><div class="line">&lt;view wx:else&gt;You neither Tom nor Anna.&lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>两个花括号所包含的判断条件中的变量于主程序 JS 代码中的data 中声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">boyname: &apos;Tom&apos;,</div><div class="line">girlname: &apos;Anna&apos;</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>若需要在界面中构建一个列表，可以使用 WXML 中的循环渲染，将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data 中供 WXML 访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</div><div class="line">&#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;</div><div class="line">&lt;/view&gt;</div><div class="line">Page(&#123;</div><div class="line">data: &#123;</div><div class="line">array: [&#123;</div><div class="line">message: &apos;foo&apos;,</div><div class="line">&#125;, &#123;</div><div class="line">message: &apos;bar&apos;</div><div class="line">&#125;]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染完毕后，渲染判断条件的变动可以影响界面变动。</p>
<h4 id="4-模板与引用"><a href="#4-模板与引用" class="headerlink" title="4. 模板与引用"></a>4. 模板与引用</h4><p>WXML 支持使用模板与引用减少代码体积。模板是在 WXML 代码中对相同的代码进行复用的方式。可以将多个模板写入至同一文件，并使用 import 在其他文件中进行引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template name=&quot;grettings&quot;&gt;</div><div class="line">&lt;view&gt;</div><div class="line">&lt;text&gt;Hello, &#123;&#123;name&#125;&#125;&lt;/text&gt;</div><div class="line">&lt;/view&gt;</div><div class="line">&lt;/template&gt;//some other codes</div><div class="line">&lt;template is=&quot;grettings&quot; data=&quot;&#123;&#123;...name&#125;&#125;&quot; /&gt;</div></pre></td></tr></table></figure></p>
<p>如果需要整个页面引用，需要使用到 include。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;include src=&quot;header.wxml&quot;/&gt;</div><div class="line">&lt;view&gt; body &lt;/view&gt;</div><div class="line">&lt;include src=&quot;footer.wxml&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="5-样式"><a href="#5-样式" class="headerlink" title="5. 样式"></a>5. 样式</h4><p>通过 WXSS 样式表，开发者可以定义 WXML 中的元素样式。WXSS 与 CSS 代码一样，可以直接使用选择器选择元素。在 WXML中也可以直接定义元素的 id 和 class 以便于在 WXSS 文件中进<br>行样式定义。</p>
<h4 id="6-用户操作与事件响应"><a href="#6-用户操作与事件响应" class="headerlink" title="6. 用户操作与事件响应"></a>6. 用户操作与事件响应</h4><p>由于微信使用的不是 HTML，所以也不能通过添加超链接（ a 元素）的方式来监测用户的点击事件。对于需要监听点击事件的元素，应该在 WXML 中使用 bindtap 属性或 catchtap 属性进行绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;view bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</div></pre></td></tr></table></figure></p>
<p>除了点击一次，微信也提供按住、开始触摸、松手等事件响应在 WXML 中绑定好一个事件之后，就能在主程序 JS 中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">tapName: function(someThingHere)&#123;</div><div class="line">// 执行这部分代码</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>其他 API 中也有其他相应的事件，这些事件可以在微信小程序的官方文档中查阅到。当 需 要 在 小 程 序 的 页 面 间 进 行 跳 转 时 ， 应 该 使 用wx.navigateTo() 方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tapName: function() &#123;</div><div class="line">wx.navigateTo(&#123;</div><div class="line">url: &apos;../logs/logs&apos;</div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，有关于页面层级跳转，微信将层级跳转限制到了五层。在开发时需要注意是否超过了相应限制。</p>
<h2 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a>网络访问</h2><p>小程序支持三种请求方式。一种是直接的 HTTP 连接请求，请求后直接返回结果，连接结束。另一种是 Socket 持续性连接，当一方主动关闭连接时，连接结束。除了以上两种收发纯文本的连接方式，微信还提供了一个文件收发接口。小程序中录制的语音以及选择的照片都需要这个方式来进行上传。通过小程序访问网络需要服务器端必须支持 HTTPS 安全连接，且端口号必须为 443。同时，小程序只能访问开发者在登记小程序时所设定的服务器地址。</p>
<h2 id="多媒体与存储"><a href="#多媒体与存储" class="headerlink" title="多媒体与存储"></a>多媒体与存储</h2><p>若需在小程序中播放多媒体（包括音视频）或进行数据存储，不能使用 HTML 5 中所提供的标准，必须使用微信提供的小程序多媒体播放控制接口及存储接口等。<br>有关于声音的接口有音频播放与音乐播放两种接口。音频播放提供了播放、暂停和停止播放三种接口，不提供跳转至某个播放时间点的功能，也不能获取目前的播放进度。音乐播放接口提供除以上的基础播放控制外的音乐状态检查和监听等功能。小程序提供照片和视频数据交换接口。通过这个接口，小程序可以访问用户选定或拍摄的照片与视频。通过音频录制和视频照片接口获得的多媒体信息是临时的，需要通过小程序存储文件接口对文件进行永久保存。对于文本数据，小程序也提供了存储这类数据的接口。从诸如Android 或其他 app 平台转向的开发者需要注意的是，小程序不提供数据库式的本地数据保存形式，而是通过 「字段 - 值」的一对一形式进行保存。</p>
<h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><p>小程序依托于微信，提供许多与硬件有关的 API。以下数据，小程序可以通过 API 获取到。<br>1.系统相关信息（包括网络状态、设备型号、窗口尺寸等）<br>2.重力感应数据<br>3.罗盘数据<br>通过以上 API，应该可以轻松写出「摇一摇」等互动性页面。但需要注意：由于这些数据只能主动获取，而不能通过这些数值变化的回调实时获取。</p>
<h2 id="推送服务"><a href="#推送服务" class="headerlink" title="推送服务"></a>推送服务</h2><p>小程序提供有推送服务，可以随时向用户发送必要的通知。但请注意，推送服务只能用于通知提醒，不能用于群发。小程序中，推送服务叫做「模板消息」（之前有开发过服务号的开发者应该比较熟悉）。开发者需要在微信小程序后台登记新的模板推送消息（比如：购买成功通知等）并审核通过后，才能在小程序中使用模板消息推送服务，具体审核标准建议参考相应文档。模板消息审核通过后，开发者需要先向微信服务器获取 Access Token，随后将该值、模板编号和模板中的动态变量（比如：订单号、价格等）提交给微信，由微信向用户推送通知。</p>
<h2 id="用户信息与微信支付"><a href="#用户信息与微信支付" class="headerlink" title="用户信息与微信支付"></a>用户信息与微信支付</h2><p>小程序可以在用户同意的前提下获取到用户的信息。小程序首先要通过微信登录的接口，让用户授权登录。之后，小程序就可以展示并使用用户信息。使用微信登录的时候需要注意，消息需要经过签名确认其完整性之后，方能保证数据未经篡改。小程序中也可以使用微信支付。需要注意的是在发送支付请求时，需要在发送的消息中添加签名，以确认消息完整性。</p>
<p>如果开发过程中遇到问题，最好的办法还是查阅微信官方的小程序开发文档，相信在文档中，你能找到绝大部分问题的解决办法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wxappintroduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/wxappintroduction/" class="article-date">
      <time datetime="2017-02-06T02:38:24.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/wxappintroduction/">微信小程序简单介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在语言方面，看上去小程序几乎重新定义了一套标准。但是实际上，它们与「前端三件套」 ——HTML、 CSS 和 JavaScript——差不太多。</p>
<h4 id="对比一下小程序开发语言和「前端三件套」有什么异同点："><a href="#对比一下小程序开发语言和「前端三件套」有什么异同点：" class="headerlink" title="对比一下小程序开发语言和「前端三件套」有什么异同点："></a>对比一下小程序开发语言和「前端三件套」有什么异同点：</h4><p>一、 HTML 与 WXML：两者差异比较大，如果之前没有接触过Android 开发，可能会觉得有些头疼。事实上， WXML 更像是 Android 开发中的界面 XML ᧿述文件，更适合于程序界<br>面的构建；而 HTML 则倾向于文章的展示（这与 HTML 的历史有关），以及互联网页面的构建。<br>二、 WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。<br>三、 JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能（如 DOM）。</p>
<p>小程序开发需要学习的语言主要有：</p>
<ol>
<li>微信标记语言  （weixin marked language,   wxml）</li>
<li>微信样式表（weixin style sheet, wxss ）</li>
<li>javascript</li>
</ol>
<p>小程序的界面并非是一个网页，而是一个应用界面，以往网页前端常见的<code>&lt;div&gt;、&lt;a&gt;</code>等标签都不复存在，网页前端开发人员需要适应wxml的逻辑和写法。</p>
<p>小程序使用了rpx（responsive pixel）作为尺寸单位（保证不同分辨率设备的元素正常显示），开发人员需要了解rpx与各种长度单位的换算比例。</p>
<h4 id="为什么需要动态单位和-rpx？"><a href="#为什么需要动态单位和-rpx？" class="headerlink" title="为什么需要动态单位和 rpx？"></a>为什么需要动态单位和 rpx？</h4><p>我们都知道，小程序是一个跨系统的平台。这就意味着，小程序会在不同的设备上运行，但不同设备的分辨率会有差异。<br>在小程序中，如何在分辨率不同的设备上保证视觉元素的正常显示？这就需要名为 rpx 的动态尺寸单位。</p>
<p>在显示屏上，每一个画面都是由无数的点阵形成的。这个点阵中，每一个点叫做像素，就是 pixel（缩写为 px）。这对于很多人来说都是常识。</p>
<p>但是，随着 Retina 屏幕（即「视网膜屏」）的推出和高分屏的普及，1 px 所能代表的实际长度并非是一成不变的。对于跨平台、跨设备的应用来说，单纯使用 px 并不能满足需要。因为，这很难保证小程序的元素，能在不同设备上正常显示——同样 px 尺寸的元素，在高分屏上显示会明显要比在低分屏显得更小。因此，我们需要一个动态的长度单位。这个单位通过对不同屏幕的分辨率进行调整和适配，保证相同元素在不同屏幕上的展示是正常的。</p>
<font color="red" face="“黑体”">苹果和 Google 对此都有相应的措施：</font>

<p>1.由于苹果对高分屏的优化良好，所以在 iOS 上，代码中的 1 px 所代表的实际像素数会根据不同设备动态调整，开发者不需要进行二次换算。<br>2.由于 Android 设备碎片化严重，Google 不得不建立了一个新的名叫「density-independent pixel（密度无关像素，缩写为 dp）」的尺寸单位，以适应不同分辨率屏幕的尺寸换算。</p>
<p>微信也为小程序提供了一个动态单位解决方案：它就是 responsive pixel（动态像素），简称 rpx。</p>
<font color="red">Pixel与rpx、dp之间的换算</font>

<p>动态单位与 px 换算的基本概念是：选择一个分辨率作为基准，在基准分辨率中，一个像素点显示有多长，在其他屏幕上会显示同样长度。<br>例如，dp 与 px 换算公式是：dp = px <em> (目标设备 dpi 分辨率 / 160)。<br>但微信小程序的 rpx 换算方式，会与其他动态单位的换算方法有些出入。微信官方提供的换算方式更「傻瓜」一些：rpx = px </em> (目标设备宽 px 值 / 750)。</p>
<font color="red" face="“黑体”">例如：</font>

<p>目标设备的宽度如果是 375px，按照 750rpx 进行换算，则等于 1rpx = 0.5px<br>目标设备的宽度如果是 1125px，换算后 1rpx = 1.5px</p>
<p>没错，如果将微信小程序放到平板电脑上运行，屏幕的宽度 px 值有可能会变化（横竖屏、分屏模式等等）。这时候，再以宽度为基准，就会出现元素显示不正确的问题。从这一点可以看出，微信团队目前并不希望将小程序扩展到手机以外的设备中。因此，开发者暂时可以专注于提高小程序在手机上的体验，无需担心多尺寸屏幕带来的适配问题。</p>
<font color="red" face="“黑体”">那能不能直接让 rpx 和 dp 进行互换呢？当然不能！</font>

<p>dp 是以屏幕分辨率为基准的动态单位，而 rpx 是以长度为基准的动态单位。就像「米」和「平方厘米」不能互换一样，dp 和 rpx 两者也是不能直接进行互换的，除非微信官方将 rpx 设定为分辨率基准而非长度基准。</p>
<h4 id="设计师该怎么做？"><a href="#设计师该怎么做？" class="headerlink" title="设计师该怎么做？"></a>设计师该怎么做？</h4><p>由于微信使用了 rpx 动态单位，设计稿的尺寸单位也推荐使用 rpx。</p>
<p>那么问题来了，如果要改用 rpx 单位，以什么尺寸的屏幕作为设计稿标准会比较合适呢？</p>
<p>在微信官方的文档中，我们看到下面这样一句话：</p>
<p>在 iPhone 6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。</p>
<p>开发微信小程序时设计师可以用 iPhone 6 作为视觉稿的标准。<br>也就是说，设计师在设计小程序时，可以这样做：<br>直接以 iPhone 6 的屏幕尺寸（375×667）用作视觉稿尺寸，1 px = 0.5 rpx；<br>以 1 px = 1 rpx 的标准，将设计稿尺寸设定为 750×1334。<br>在将设计稿转交给开发人员之前，设计师需要清楚地描述设计稿尺寸和单位换算标准等，以便开发人员快速实现界面效果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wxapp/">wxapp</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-codetest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/05/codetest/" class="article-date">
      <time datetime="2017-02-05T02:43:12.000Z" itemprop="datePublished">2017-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/05/codetest/">使用Benchmark.js和jsPerf分析代码性能</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前端开发中，掌握好浏览器的特性进行有针对性的性能调优是一项基本工作，同时，比较不同代码的执行速度也是一项关键的工作。</p>
<p>比如，当我们想比较RegExp的test方法和String对象的indexOf方法查找字符串谁的速度更快的话，js代码在不同的浏览器，不同的操作系统环境运行的效率可能是不一样的，这就是为什么我们需要对其进行基准测试，在做基准测试方面，我们可以使用Benchmark.js和使用jsPerf（一个基于JSLitmus的基准测试库）。我们可以使用jsPerf来分享你的基准测试。</p>
<h4 id="Benchmark-js-的使用"><a href="#Benchmark-js-的使用" class="headerlink" title="Benchmark.js 的使用"></a>Benchmark.js 的使用</h4><p>其实在很多github 开源项目中，往往都能看到benchmark文件夹。使用方法如下：<br>首先在系统根目录下，通过npm intsall benchmark 来安装benchmark。该模块会被写入node_modules文件夹中，我们在test.js文件中通过require方法引入该模块。<br>将如下代码写入test.js文件，该文件置于系统根目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Benchmark = require(&apos;benchmark&apos;);</div><div class="line">var suite = new Benchmark.Suite;</div><div class="line"></div><div class="line">// 添加测试</div><div class="line">suite.add(&apos;RegExp#test&apos;, function() &#123;</div><div class="line">    /o/.test(&apos;Hello World!&apos;);</div><div class="line">&#125;)</div><div class="line">    .add(&apos;String#indexOf&apos;, function() &#123;</div><div class="line">        &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</div><div class="line">    &#125;)</div><div class="line">// add listeners</div><div class="line">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class="line">        console.log(String(event.target));</div><div class="line">    &#125;)</div><div class="line">    .on(&apos;complete&apos;, function() &#123;</div><div class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class="line">    &#125;)</div><div class="line">// run async</div><div class="line">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>
<p>然后在控制台执行node test.js 可见输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ git:(master) ✗ node test.js</div><div class="line">RegExp#test x 9,847,928 ops/sec ±1.47% (83 runs sampled)</div><div class="line">String#indexOf x 23,366,017 ops/sec ±0.91% (96 runs sampled)</div><div class="line">Fastest is String#indexOf</div></pre></td></tr></table></figure></p>
<p>结果最快的就是String对象的indexOf方法，其中，Ops/sec 测试结果以每秒钟执行测试代码的次数（Ops/sec）显示，这个数值越大越好。除了这个结果外，同时会显示测试过程中的统计误差，以及相对最好的慢了多少（%）;</p>
<p><font color="red">call和apply的比较</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var Benchmark = require(&apos;benchmark&apos;);</div><div class="line">var suite = new Benchmark.Suite;</div><div class="line">var arr1 = function (str) &#123;</div><div class="line">    return [].slice.apply(str);</div><div class="line">&#125;;</div><div class="line">var str2 = function (str) &#123;</div><div class="line">    return [].slice.call(str);</div><div class="line">&#125;;</div><div class="line">// 添加测试</div><div class="line">suite.add(&apos;arr1&apos;, function() &#123;</div><div class="line">    arr1(&apos;test&apos;);</div><div class="line">&#125;)</div><div class="line">    .add(&apos;str2&apos;, function() &#123;</div><div class="line">        str2(&apos;test&apos;);</div><div class="line">    &#125;)</div><div class="line">// add listeners</div><div class="line">    .on(&apos;cycle&apos;, function(event) &#123;</div><div class="line">        console.log(String(event.target));</div><div class="line">    &#125;)</div><div class="line">    .on(&apos;complete&apos;, function() &#123;</div><div class="line">        console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).pluck(&apos;name&apos;));</div><div class="line">    &#125;)</div><div class="line">// run async</div><div class="line">    .run(&#123; &apos;async&apos;: true &#125;);</div></pre></td></tr></table></figure></p>
<p>输出如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr1 x 596,505 ops/sec ±1.14% (95 runs sampled)</div><div class="line">str2 x 627,822 ops/sec ±1.27% (92 runs sampled)</div><div class="line">Fastest is str2</div></pre></td></tr></table></figure></p>
<p><font color="red">本地的使用</font><br>本地使用Benchmark需要引入如下三个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;platform.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;benchmark.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h4 id="jsPerf-的使用"><a href="#jsPerf-的使用" class="headerlink" title="jsPerf 的使用"></a>jsPerf 的使用</h4><p>jsPerf 提供了一个简便的方式来创建和共享测试用例，并可以比较不同JavaScript代码段的性能。jsPerf也是基于Benchmark来运行的。<br>打开jsPerf站点：<a href="http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code" target="_blank" rel="external">http://jsperf.com/，先将必填的项目填了。其中，slug是短名称，会生成一个网址，因此不可与别人的重复。然后在Code</a> snippets to compare 区域填入title和用于测试的code。最后点击save test case 完成验证即可。浏览器会自动跳转到测试页面.<br>Async选项框是用来测试一些异步调用的性能的，我们的代码没有使用异步方法，所以不必勾选。</p>
<p><font color="red">运行测试</font><br>点击“Run tests”按钮开始测试两种算法的性能。建议在运行性能测试之前，关闭无关的浏览器页面，关闭其他程序，退出不必要的后台进程，以保证结果不受其他环境的影响。你也可以通过点击个别测试用例的名字单独运行这个例子.<br>jsPerf还会统计所有运行过这个测试用例的浏览器的比较结果，显示在下方的Browserscope区域，可以通过它直观地看出各个版本浏览器的性能横向和纵向比较情况。</p>
<p><font color="red">查看别人的测试用例</font><br>我们可以通过 <a href="http://jsperf.com/browse" target="_blank" rel="external">http://jsperf.com/browse</a> 浏览最新提交的250项最新测试用例。我们也可以使用底部的Revisions来查看不同的版本，也就是不同浏览器的测试用例情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>John Resig 在其博文 JavaScript基准测试的质量中提到，应该尽量考虑到每个测试结果的误差并去减小它。扩大测试的样本值，健全的测试执行，都能够起到减少误差的作用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Benchmark-jsPerf/">Benchmark jsPerf</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-performancetest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/05/performancetest/" class="article-date">
      <time datetime="2017-02-05T01:37:46.000Z" itemprop="datePublished">2017-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/05/performancetest/">性能测试与调优</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var start = (new Date()).getTime(); // 或者Date.now()</div><div class="line">// 进行一些操作</div><div class="line">var end = (new Date()).getTime();</div><div class="line">console.log( &quot;Duration:&quot;, (end - start) );</div></pre></td></tr></table></figure></p>
<p>上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。<br>如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！</p>
<p>还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。</p>
<p>如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。</p>
<p>更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。</p>
<p><font color="red">重复</font><br>“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。</p>
<p><font color="red">Benchmark.js</font><br>任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：<a href="http://benchmarkjs.com/" target="_blank" rel="external">http://benchmarkjs.com/</a><br>Benchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。<br>为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">// 要测试的运算</div><div class="line">&#125; v</div><div class="line">ar bench = new Benchmark(</div><div class="line">&quot;foo test&quot;, // 测试名称</div><div class="line">foo, // 要测试的函数（也即内容）</div><div class="line">&#123;</div><div class="line">// .. // 可选的额外选项（参见文档）</div><div class="line">&#125;</div><div class="line">);</div><div class="line">bench.hz; // 每秒运算数</div><div class="line">bench.stats.moe; // 出错边界</div><div class="line">bench.stats.variance; // 样本方差</div></pre></td></tr></table></figure></p>
<p>在上面的代码片段中， 其实忽略了“额外选项”<code>{ .. }</code> 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。<br>提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。</p>
<h4 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h4><p>尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。</p>
<p>比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。</p>
<p>有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（<a href="http://jsperf.com）" target="_blank" rel="external">http://jsperf.com）</a> 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。</p>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>ES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。<br>简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。<br>以下是一个非递归的尾调用的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">return x;</div><div class="line">&#125; f</div><div class="line">unction bar(y) &#123;</div><div class="line">return foo( y + 1 ); // 尾调用</div><div class="line">&#125;function baz() &#123;</div><div class="line">return 1 + bar( 40 ); // 非尾调用</div><div class="line">&#125; b</div><div class="line">az(); // 42</div></pre></td></tr></table></figure></p>
<p>foo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。<br>调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。<br>然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。<br>ES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。</p>
<p>从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。</p>
<p>尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-性能调试-Benchmark-jsPerf/">js 性能调试 Benchmark jsPerf</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-wsdevwechat" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/04/wsdevwechat/" class="article-date">
      <time datetime="2017-02-04T09:20:57.000Z" itemprop="datePublished">2017-02-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/04/wsdevwechat/">webstorm开发微信小程序代码提醒</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>使用了微信提供的开发工具是真心难用，卡顿厉害、中英文切写注释换相当不爽、还没办法多开窗口，相信大家也遇到过这种现象。</p>
<p>下边我们介绍下webstorm来开发微信小程序的一些配置：</p>
<p>一、 首先File下找到settings,再找到FileType下Cascading Style Sheet 添加*.wxss</p>
<div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/ws1.jpg-public" alt=""><br></div>

<p>二、 FileType下HTML 添加*.wxml</p>
<div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/ws2.jpg-public" alt=""><br></div>

<p>三、 将wecharCode.jar下载下来，然后在webStorm 的 File -&gt; import settings 中导入即可<br><a href="https://github.com/qbright/wechatCode-complete" target="_blank" rel="external">wecharCode.jar下载地址-点击即可</a></p>
<p>四、 配置已经完成，接下来你的代码就能出现微信小程序的代码提醒了。</p>
<div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/ws3.jpg-public" alt=""><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat-webstorm/">wechat webstorm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-yarn-introduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/12/yarn-introduction/" class="article-date">
      <time datetime="2017-01-12T02:55:40.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/yarn-introduction/">YARN, 一个可能取代npm的javascript包管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Facebook刚刚推出了一款名叫Yarn的开源JavaScript包管理器，承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，该公司称Yarn可以将安装时间从数分钟减少至几秒钟.</p>
<p>它的目的是解决这些团队使用 npm 面临的少数问题，即：<br>1.安装的时候无法保证速度/一致性<br>2.安全问题，因为 npm 安装时允许运行代码</p>
<h4 id="yarn-lock-文件"><a href="#yarn-lock-文件" class="headerlink" title="yarn.lock 文件"></a>yarn.lock 文件</h4><p>npm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。</p>
<p>理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。</p>
<p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。</p>
<p>在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。</p>
<p>yarn管理器有一个很重要的文件需要注意，就是yarn.lock，这个是用来依赖的正确性，快速可靠安装的；是执行cli的时候自动生成的，在项目的根目录下，需要保留！！！！不要编辑它，这是自动生成的.在其他电脑初始化，必须记得把package.json和yarn.lock复制过去，简直就是秒下载【缓存机制】.</p>
<h4 id="并行安装"><a href="#并行安装" class="headerlink" title="并行安装"></a>并行安装</h4><p>每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p>
<h4 id="Yarn-vs-npm-CLI-的差异"><a href="#Yarn-vs-npm-CLI-的差异" class="headerlink" title="Yarn vs npm: CLI 的差异"></a>Yarn vs npm: CLI 的差异</h4><p>除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。</p>
<ul>
<li>yarn global<br>不像 npm 添加 -g 或 –global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。</li>
</ul>
<p>global 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除yarn add 外，这些命令都和 npm 等效。</p>
<ul>
<li><p>npm install<br>npm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。</p>
</li>
<li><p>yarn add [–dev]</p>
</li>
</ul>
<p>与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 –save 参数；Yarn 的 –dev 参数则是添加开发依赖，类似 npm 的 –save-dev 参数。</p>
<ul>
<li>yarn licenses [ls|generate-disclaimer]</li>
</ul>
<p>npm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。</p>
<ul>
<li>yarn why</li>
</ul>
<p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。</p>
<ul>
<li>yarn upgrade</li>
</ul>
<p>该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm -rf node_modules</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。</p>
<ul>
<li>yarn generate-lock-entry</li>
</ul>
<p>yarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。</p>
<h4 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h4><p>npm install -g yarn</p>
<h4 id="常用命令快速对比"><a href="#常用命令快速对比" class="headerlink" title="常用命令快速对比"></a>常用命令快速对比</h4><p>npm install  =&gt; yarn install<br>npm install –save =&gt; yarn add<br>npm install –save-dev =&gt; yarn add -dev</p>
<h4 id="针对国内的设置"><a href="#针对国内的设置" class="headerlink" title="针对国内的设置"></a>针对国内的设置</h4><p>如果没有出现网络问题，请直接忽略下面的内容。如果出现错误可以考虑设置一下npm源，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn config set registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/yarn-npm/">yarn npm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node-interview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/11/node-interview/" class="article-date">
      <time datetime="2017-01-11T09:21:52.000Z" itemprop="datePublished">2017-01-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/11/node-interview/">Node.js 面试问题及答案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="Node-js-面试问题预览-来源于网络"><a href="#Node-js-面试问题预览-来源于网络" class="headerlink" title="Node.js 面试问题预览(来源于网络)"></a>Node.js 面试问题预览(来源于网络)</h4><ul>
<li>什么是 error-first 回调模式？</li>
<li>如何避免“回调地狱”？</li>
<li>什么是 Promises？</li>
<li>什么工具统一团队的代码风格？为什么统一的代码风格很重要？</li>
<li>什么时候应当用 npm？什么时候应当用 yarn？</li>
<li>什么是桩代码（stub）？ 请描述一个应用场景！</li>
<li>什么是测试金字塔？请举例说明！</li>
<li>你最欣赏的 HTTP 框架是什么？为什么？</li>
<li>如果保证你的 cookie 安全？如何阻止 XSS 攻击？</li>
<li>如何确认项目的相关依赖安全？<h4 id="什么是-error-first-回调模式？"><a href="#什么是-error-first-回调模式？" class="headerlink" title="什么是 error-first 回调模式？"></a>什么是 error-first 回调模式？</h4>应用 error-first 回调模式是为了更好的进行错误和数据的传递。第一个参数保留给一个错误 error 对象，一旦出错，错误将通过第一个参数 error 返回。其余的参数将用作数据的传递。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(filePath,function (err,data) &#123;</div><div class="line">    if(err)&#123;</div><div class="line">        //handle the error code.</div><div class="line">        return console.log(err);</div><div class="line">    &#125;</div><div class="line">    console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="如何避免“回调地狱”"><a href="#如何避免“回调地狱”" class="headerlink" title="如何避免“回调地狱”?"></a>如何避免“回调地狱”?</h4><p>解决这个问题的方法有很多:</p>
<ul>
<li>模块化设计: 讲回调拆分成几个独立的函数</li>
<li>使用 流程控制库, 比如 async</li>
<li>组合使用 generators 和 Promises</li>
<li>使用 async/await 函数 (只能在Node v7 release版本运行， Node LTS版本尚不支持 )</li>
</ul>
<h4 id="什么是-Promises"><a href="#什么是-Promises" class="headerlink" title="什么是 Promises?"></a>什么是 Promises?</h4><p>promise的概念早在上个世纪八十年代就被提出，现在已经是大多数现代编程语言中支持的特性，让你能更轻松地实现异步模型。</p>
<p>举个简单的例子, 正常来说100ms 之后将会输出 result 。一旦失败, catch可以抛出异常。Promises允许链式操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Promise(()=&gt;&#123;</div><div class="line">    setTimeout(()=&gt;&#123;</div><div class="line">        resolve(&apos;result&apos;)</div><div class="line">    &#125;,100)&#125;)</div><div class="line">    .then((data)=&gt;&#123;</div><div class="line">        console.log(data);</div><div class="line">    &#125;)</div><div class="line">    .catch();</div></pre></td></tr></table></figure></p>
<h4 id="什么工具统一团队的代码风格-为什么统一的代码风格很重要？"><a href="#什么工具统一团队的代码风格-为什么统一的代码风格很重要？" class="headerlink" title="什么工具统一团队的代码风格? 为什么统一的代码风格很重要？"></a>什么工具统一团队的代码风格? 为什么统一的代码风格很重要？</h4><p>团队协作时，始终如一的代码风格十分重要，代码风格一致，团队成员可以更轻松的构建项目，不用为每次构建项目都使用新的代码风格而担心。<br>同时, 始终如一的代码风格，可以通过静态分析排除代码问题。</p>
<p>帮助规范代码的工具: 1.ESLint 2.Standard<br>如果你想更上一层楼，可以学习 JavaScript Clean Coding 原则。</p>
<h4 id="什么时候应当用-npm？什么时候应当用-yarn？"><a href="#什么时候应当用-npm？什么时候应当用-yarn？" class="headerlink" title="什么时候应当用 npm？什么时候应当用 yarn？"></a>什么时候应当用 npm？什么时候应当用 yarn？</h4><p>相同点：都是javascript包管理器。<br>yarn 解决了npm历史遗留下来的痛点。<br>yarn特点：多平台精确校准，只要将yarn.lock保存到源码库里，在任何地方用yarn安装，版本都不会偏差。从而避免了package.json原来经常出现小版本差异而导致程序无法正常运行的情况。<br>缓存已经下载过的包，避免重复下载<br>下载前会检查签名及包的完整性<br>可靠可确定性，保证各平台依赖的一致性<br>网络优化，力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败<br>扁平化模式，对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。（可以做个测试当时加载某个项目 用了86秒，后面又用npm测试，用了 190秒，之后在用yarn.lock 的情况下，加载用了46秒）</p>
<h4 id="什么是桩代码（stub）-请描述一个应用场景！"><a href="#什么是桩代码（stub）-请描述一个应用场景！" class="headerlink" title="什么是桩代码（stub）? 请描述一个应用场景！"></a>什么是桩代码（stub）? 请描述一个应用场景！</h4><p>桩代码（stub）就是在某些组件或模块中，模拟某些功能的代码。桩代码（stub）的作用是占位，让代码在测试过程中顺利运行。</p>
<p>一个例子，它实际的作用是写一个文件，但是这段代码并没有真正的做这件事。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var writeFileStub = sinon.stub(fs,&apos;writeFile&apos;,function (path,data,cb) &#123;</div><div class="line">    return cb(null);</div><div class="line">&#125;);</div><div class="line">expect(writeFileStub).to.be.called</div><div class="line">writeFileStub.restore();</div></pre></td></tr></table></figure></p>
<h4 id="什么是测试金字塔？请举例说明！"><a href="#什么是测试金字塔？请举例说明！" class="headerlink" title="什么是测试金字塔？请举例说明！"></a>什么是测试金字塔？请举例说明！</h4><p>测试金字塔描述了单元测试（unit test），集成测试（integration tests），端到端测试（end-to-end test）在测试中占的比例。</p>
<div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/testjinzita.jpg-public" alt=""><br></div>

<p>举个例子，测试一个 HTTP API 需要:<br>1.大量关于 models 的单元测试(使用桩代码处理),<br>2.一些关于 models 如何和其他 models 交互的集成测试 (未使用桩代码处理),<br>3.少量的端到端测试，也就是真实环境下的调用 ( 未使用桩代码处理).</p>
<h4 id="你最欣赏的-HTTP-框架是什么？为什么？"><a href="#你最欣赏的-HTTP-框架是什么？为什么？" class="headerlink" title="你最欣赏的 HTTP 框架是什么？为什么？"></a>你最欣赏的 HTTP 框架是什么？为什么？</h4><p>这道题没有标准答案。出这道题的目的是，看看面试者对他所使用框架，理解的有多深。只要面试者回答出框架的优缺点，为什么使用这个框架就可以了。</p>
<h4 id="什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？"><a href="#什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务-怎么给-worker-安排任务？" class="headerlink" title="什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？"></a>什么时候应该在后台进程中使用消息服务？怎么处理工作线程的任务/怎么给 worker 安排任务？</h4><p>消息队列适用于后台数据传输服务，比如发送邮件和数据图像处理。</p>
<p>消息队列有很多解决方案，比如 RabbitMQ 和 Kafka.</p>
<h4 id="如何保证你的-cookie-安全？如何阻止-XSS-攻击？"><a href="#如何保证你的-cookie-安全？如何阻止-XSS-攻击？" class="headerlink" title="如何保证你的 cookie 安全？如何阻止 XSS 攻击？"></a>如何保证你的 cookie 安全？如何阻止 XSS 攻击？</h4><p>XSS 攻击是指攻击者向Html页面里插入恶意 JavaScript 代码。</p>
<p>为了防止攻击，你需要对 HTTP header 里的 set-cookie 进行处理:<br>1、HttpOnly - 这个属性帮助防止跨站脚本攻击，它禁止通过 JavaScript 访问 cookie。<br>2、secure - 这个属性告诉浏览器，仅允许通过 HTTPS 协议访问 cookie。</p>
<p>所以，你需要做的是在请求头里写 Set-Cookie: sid=; HttpOnly。如果你正在使用 Express 框架，可以使用 express-cookie session，他会默认做出上述防止 XSS 攻击的设置。</p>
<h4 id="如何确认项目的相关依赖安全？"><a href="#如何确认项目的相关依赖安全？" class="headerlink" title="如何确认项目的相关依赖安全？"></a>如何确认项目的相关依赖安全？</h4><p>使用 Node.js 开发, 很容易出现有成百上千个依赖的情况。</p>
<p>举例来说，如果你依赖 Express，准确的说这意味着也依赖 27 个其他的模块 , 手动检测更新这些模块不是一个正确的选择！</p>
<p>唯一的选择就是自动的安全的更新你的依赖，你有如下免费或付费的选择：<br>1、pm outdated<br>2、race by RisingStack<br>3、SP<br>4、reenKeeper<br>5、nyk</p>
<h4 id="下面的代码有什么错误？"><a href="#下面的代码有什么错误？" class="headerlink" title="下面的代码有什么错误？"></a>下面的代码有什么错误？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Promise((resolve,reject)=&gt;&#123;</div><div class="line">    throw new Error(&apos;error&apos;)</div><div class="line">&#125;).then(console.log)</div><div class="line">//在 then 后没有 catch ，没有捕捉异常。这样做会造成故障沉默，不会抛出异常。</div><div class="line">//如果你调试一个巨大的代码库，并且不知道哪个 Promise 函数有潜在的问题, 你可以使用 unhandledRejection 这个工具。它将会打印出所有未处理的 reject 状态的 Promise。</div><div class="line">process.on(&apos;unhandleRejection&apos;,(err)=&gt;&#123;</div><div class="line">    console.log(err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class="line">    if(apiKeyFromDb===apiKeyReceived)&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">//在进行数据校验(security credentials)时，避免任何信息泄露是最重要的。所以，我们要控制数据校验的执行时间。我们要保证，不管传过来的数据是什么，我们校验数据消耗的时间是相同的。如果你做不到这一点，你的程序对时序攻击的抵抗力很低。</div><div class="line"></div><div class="line">为什么会有这种现象?</div><div class="line">Node.js 使用 JavaScript V8 引擎, 为了高速运行网页而开发的，性能优异。 V8 引擎比较数据的方式是字节比较, 一旦发现有一个字节不一致, 比较运算就会停止。 因此，攻击者传入的 password 校验时间越长，说明明 password 正确的部分越多。</div><div class="line">为了修复这个问题, 你可以使用 npm 模块 cryptiles。</div><div class="line"></div><div class="line">function checkApiKey(apiKeyFromDb,apiKeyReceived) &#123;</div><div class="line">    return cryptiles.fixedTimeComparison(apiKeyFromDb,apiKeyReceived)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">下面这段代码输出的是什么?</div><div class="line">Promise.resolve(1)</div><div class="line">    .then((x)=&gt;x+1)</div><div class="line">    .then((x)=&gt;&#123;throw new Error(&apos;My Error&apos;)&#125;)</div><div class="line">    .catch(()=&gt;1)</div><div class="line">    .then((x)=&gt;x+1)</div><div class="line">    .then((x)=&gt;console.log(x))</div><div class="line">    .catch(console.error)</div><div class="line">答案是 2. 每行代码对应解释如下：</div><div class="line">创建一个 Promise 对象，输出 1</div><div class="line">创建一个 Promise 对象，输出 1</div><div class="line">结果 +1，现在的输出为2</div><div class="line">输出结果被抛弃，抛出一个 error</div><div class="line">error 被丢弃, 返回一个新的 value (1)</div><div class="line">catch 进行异常处理，但 catch 后程序不停止执行, 返回一个信息+1之后的 value (2)</div><div class="line">value 正常输出</div><div class="line">value 已正常输出，这一行不会执行</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nodejs/">nodejs</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Wenxi Yan
            </div>
            <div class="footer-right">
                <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >用户到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>