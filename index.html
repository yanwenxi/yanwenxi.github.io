<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人博客">
<meta property="og:url" content="http://yanwenxi.github.io/index.html">
<meta property="og:site_name" content="闫文喜的个人博客">
<meta property="og:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人博客">
<meta name="twitter:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Wenxi Yan</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">我的小窝</a></li>
                        
                            <li><a href="/archives">文章列表</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                            
                                <a class="fl wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-1px/" style="font-size: 10px;">css 1px</a> <a href="/tags/css-前端开发/" style="font-size: 10px;">css 前端开发</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css3/" style="font-size: 10px;">flex css3</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/i18n/" style="font-size: 10px;">i18n</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试-Benchmark-jsPerf/" style="font-size: 10px;">js 性能调试 Benchmark jsPerf</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/js继承、原型链/" style="font-size: 10px;">js继承、原型链</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/nginx/" style="font-size: 12.5px;">nginx</a> <a href="/tags/node/" style="font-size: 12.5px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 20px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 17.5px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 20px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vue、mvvm/" style="font-size: 10px;">vue、mvvm</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 15px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端工程-构建工具-前端开发/" style="font-size: 10px;">前端工程 构建工具 前端开发</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com">前端小站</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://ywxi.github.io/">web博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">运动健身、网络营销、web前端、喜欢接触新鲜事物、迎接新的挑战</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Wenxi Yan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Wenxi Yan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">我的小窝</a></li>
                
                    <li><a href="/archives">文章列表</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-1px" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/10/15/1px/" class="article-date">
      <time datetime="2018-10-15T06:12:39.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/1px/">移动端1px细线解决方案总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="移动端1px变粗的原因"><a href="#移动端1px变粗的原因" class="headerlink" title="移动端1px变粗的原因"></a>移动端1px变粗的原因</h3><p>为什么移动端css里_面写了1px，实际看起来比1px粗，其实原因很好理解：这两个”px”的含义是不一样的,移动端html里的header里总会有一句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都为1，并禁用了用户缩放，viewport通俗地讲是浏览器上可用来显示页面的区域，这个区域是可能比屏幕大的。</p>
<p> 手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.</p>
<p>以实际举例: iphone3和iphone4的屏幕宽度分别是320px,640px, 但是它们的ideal viewport的宽度都是320px, 设置了设备宽度后, 320px宽的元素都能100%的填充满屏幕宽. 不同手机的ideal viewport宽度是不一样的, 常见的有320px, 360px, 384px. iphone系列的这个值在6之前都是320px, 控制viewport的好处就在于一套css可以适配多个机型.</p>
<p>看懂的人应该已经明白 1px变粗的原因了, viewport的设置和屏幕物理分辨率是按比例而不是相同的. <strong>移动端window对象有个devicePixelRatio属性, 它表示设备物理像素和css像素的比例, 在retina屏的iphone手机上, 这个值为2或3, css里写的1px映射到物理像素上就有2px或3px那么粗.</strong></p>
<h3 id="1px解决方案"><a href="#1px解决方案" class="headerlink" title="1px解决方案"></a>1px解决方案</h3><h4 id="1、用小数来写px值"><a href="#1、用小数来写px值" class="headerlink" title="1、用小数来写px值"></a>1、用小数来写px值</h4><p>IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">    .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">    .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点: 安卓与低版本IOS不适用, 这个或许是未来的标准写法.</p>
<h4 id="2、scale缩放的方式"><a href="#2、scale缩放的方式" class="headerlink" title="2、scale缩放的方式"></a>2、scale缩放的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.border-1px &#123;  </span><br><span class="line">            position: relative;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">.border-1px::after &#123;  </span><br><span class="line">            display: block;  </span><br><span class="line">            position: absolute;  </span><br><span class="line">            left: 0;  </span><br><span class="line">            bottom: 0;  </span><br><span class="line">            width: 100%;  </span><br><span class="line">            border-top: 1px solid red;  </span><br><span class="line">            content: &apos;  &apos;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line"> @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio:1.5) &#123;  </span><br><span class="line"> 		.border-1px::after &#123;  </span><br><span class="line">		 -webkit-transform: scaleY(0.7);  </span><br><span class="line"> 		transform: scaleY(0.7)  </span><br><span class="line">            &#125;  </span><br><span class="line">       </span><br><span class="line">       @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio:2)       &#123;</span><br><span class="line">       .border-1px::after &#123;  </span><br><span class="line">       -webkit-transform: scaleY(0.5);  </span><br><span class="line">       transform: scaleY(0.5)  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、rem解决方案"><a href="#3、rem解决方案" class="headerlink" title="3、rem解决方案"></a>3、rem解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//根据屏幕大小及dpi调整缩放和大小  </span><br><span class="line">(function () &#123;</span><br><span class="line">        var scale = 1.0;</span><br><span class="line">        var ratio = 1;</span><br><span class="line">        if (window.devicePixelRatio &gt;= 2) &#123;</span><br><span class="line">            scale *= 0.5;</span><br><span class="line">            ratio *= 2;</span><br><span class="line">        &#125;</span><br><span class="line"> var text = &apos;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;,&apos; + &apos; minimum-scale=&apos; + scale + &apos;, width=device-width,&apos; + &apos; user-scalable=no&quot; /&gt;&apos;;</span><br><span class="line">   document.write(text);</span><br><span class="line">   document.documentElement.style.fontSize = 50 * ratio + &quot;px&quot;;&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4、其他方式"><a href="#4、其他方式" class="headerlink" title="4、其他方式"></a>4、其他方式</h4><p>比如：背景图图片、背景图渐变、js判断支持0.5px(和方案1类似)；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-1px/">css 1px</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/15/Promise/" class="article-date">
      <time datetime="2018-05-15T06:12:39.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/Promise/">promise学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h3><p>Promise 是异步编程的一种解决方案，它有三种状态，分别是pending(进行中)、</p>
<p>resolved(已完成)、rejected(已失败)。</p>
<p>当Promsie的状态由pending转变成resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是Promise-承诺名字的由来。</p>
<h3 id="ES6之前的promise"><a href="#ES6之前的promise" class="headerlink" title="ES6之前的promise"></a>ES6之前的promise</h3><p>使用较为成熟的第三方promise库—<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">Bluebird</a>,它是实现promise标准库功能最全、速度最快的一个库。</p>
<p>经典使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&apos;./bluebird&apos;);</span><br><span class="line"></span><br><span class="line">var readFile = Promise.promisify(require(&quot;fs&quot;).readFile);</span><br><span class="line">readFile(&quot;1.txt&quot;, &quot;utf8&quot;).then(function(contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var fs = Promise.promisifyAll(require(&quot;fs&quot;));</span><br><span class="line"></span><br><span class="line">fs.readFileAsync(&quot;1.txt&quot;, &quot;utf8&quot;).then(function (contents) &#123;</span><br><span class="line">    console.log(contents);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="ES6的promise-基本使用方法"><a href="#ES6的promise-基本使用方法" class="headerlink" title="ES6的promise 基本使用方法"></a>ES6的promise 基本使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    if(success)&#123;</span><br><span class="line">        resolve(successData)//pending=&gt;resolved,参数传递给对应的回调方法</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(failData) //pending=&gt;rejected,参数传递给对应的回调方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">注：实例化的Promsie对象会立即执行。</span><br></pre></td></tr></table></figure>
<h3 id="then-和catch-方法"><a href="#then-和catch-方法" class="headerlink" title="then()和catch()方法"></a>then()和catch()方法</h3><p>Promise.prototype.then()是Promise原型链上的方法，它有两个参数(都是函数)，分别对应resolved的回调和rejected的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    (successData) =&gt; &#123; console.log(&apos;我是成功的回调参数是successData&apos;) &#125;,</span><br><span class="line">    (failData) =&gt; &#123; console.log(&apos;我是失败的回调参数是failData&apos;) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>.catch()也是原型链上的方法，作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>同样，catch()中也可以抛出错误，由于抛出的错误会在下一个catch中被捕获处理，因此可以再添加catch()；</p>
<p>当状态已经改变为resolved后，即使抛出错误，也不会触发then()的错误回调或者catch()方法；</p>
<p>then() 和 catch() 都会返回一个新的Promise对象，可以链式调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">).then(</span><br><span class="line">    ...</span><br><span class="line">).catch(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise实例的异步方法和then-中返回promise有什么区别？"><a href="#Promise实例的异步方法和then-中返回promise有什么区别？" class="headerlink" title="Promise实例的异步方法和then()中返回promise有什么区别？"></a>Promise实例的异步方法和then()中返回promise有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// p1异步方法中返回p2</span><br><span class="line">let p1 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(p2)</span><br><span class="line">&#125; )</span><br><span class="line">let p2 = new Promise ( ... )</span><br><span class="line"></span><br><span class="line">// then()中返回promise</span><br><span class="line">let p3 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125; )</span><br><span class="line">let p4 = new Promise ( ... )</span><br><span class="line">p3.then(</span><br><span class="line">    () =&gt; return p4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>p1异步方法中返回p2</strong></p>
<p>p1的状态取决于p2，如果p2为pending，p1将等待p2状态的改变，p2的状态一旦改变，p1将会立即执行自己对应的回调，即then()中的方法针对的依然是p1</p>
<p><strong>then()中返回promise</strong></p>
<p>由于then()本身就会返回一个新的promise，所以后一个then()针对的永远是一个新的promise，但是像上面代码中我们自己手动返回p4，那么我们就可以在返回的promise中再次通过 resolve() 和 reject() 来改变状态</p>
<h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>用来包装一个现有对象，将其转变为Promise对象，但Promise.resolve()会根据参数情况返回不同的Promise：</p>
<p><strong>参数是Promise</strong>：原样返回<br><strong>参数带有then方法</strong>：转换为Promise后立即执行then方法<br><strong>参数不带then方法、不是对象或没有参数</strong>：返回resolved状态的Promise</p>
<p>Promise.reject()会直接返回rejected状态的Promise;</p>
<h3 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.race([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.done()/Promise.finally()</span><br><span class="line">//上述这几个api根据api名字自己脑补吧，娃哈哈。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//学完了练一练</span><br><span class="line">一、const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">    console.log(4)</span><br><span class="line">Promise构造函数里中的代码是同步执行的，但是then方法是异步方法，then方法需要等到resolve函数执行时才能执行，所以结果是1、2、4、3.</span><br><span class="line"></span><br><span class="line">二、Promise.resolve(1).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return 2;</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line">    return 3;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">resolve(1)首先会执行第一个then函数，输出1.然后在函数中返回2，因为resolve是成功的状态，所以后面的catch不会执行，而是直接执行第二个then函数，输出2.所以结果是1、2.</span><br></pre></td></tr></table></figure>
<h3 id="Promise原理"><a href="#Promise原理" class="headerlink" title="Promise原理"></a>Promise原理</h3><p>在Promise的内部有一个状态管理器，它有三种状态：pending/fulfilled/rejected</p>
<p>1、promise对象初始化状态为pending。(new Promise时)</p>
<p>2、当调用resolve(data),状态pending=&gt;fulfilled</p>
<p>3、当调用resolve(err),状态pending=&gt;rejected</p>
<p>状态由pending变fulfilled/rejected时，一旦状态变了就不能再改变了。当状态变为fulfilled时，then的成功回调函数会被调用，并接收传来的参数data，进而进行操作，rejected则反之。promise.then方法每次执行完后，都会返回一个新的promise对象所以可以链式调用(不管是resolve还是reject).</p>
<p>举个例子来模拟Promise:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var fs=require(&apos;fs&apos;);</span><br><span class="line">var Promise = require(&apos;./Promise.js&apos;);</span><br><span class="line">var promise = new Promise(function (resolve,reject) &#123;</span><br><span class="line">    fs.readFile(&apos;1.txt&apos;,&apos;utf-8&apos;,function (err,data) &#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;,function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用es5来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">   fn((data)=&gt;&#123;</span><br><span class="line">       this._success(data);</span><br><span class="line">   &#125;,(error)=&gt;&#123;</span><br><span class="line">       this._error(error);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.then=function (onFul,onFail) &#123;</span><br><span class="line">    this._success=onFull;//</span><br><span class="line">    this._error=onFail;</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.resolve=function (data) &#123;</span><br><span class="line">    this._success(data);</span><br><span class="line">&#125;;</span><br><span class="line">Promise.prototype.reject=function (error) &#123;</span><br><span class="line">    this._error(error);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports=Promise;</span><br></pre></td></tr></table></figure>
<p>es6来模拟Promise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class promise &#123;</span><br><span class="line">    constructor(fn)&#123;</span><br><span class="line">        fn((data)=&gt;&#123;</span><br><span class="line">            this._success(data);</span><br><span class="line">        &#125;,(error)=&gt;&#123;</span><br><span class="line">            this._error(error);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data)&#123;</span><br><span class="line">        this._success(data);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(err)&#123;</span><br><span class="line">        this._error(err)</span><br><span class="line">    &#125;</span><br><span class="line">    then(onFul,onFail)&#123;</span><br><span class="line">        this._success=onFul;</span><br><span class="line">        this._error=onFail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise、es6/">promise、es6</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Vue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/15/Vue/" class="article-date">
      <time datetime="2018-04-15T06:12:39.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/Vue/">vue相关学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="查看vue-cli是否安装成功及版本号"><a href="#查看vue-cli是否安装成功及版本号" class="headerlink" title="查看vue-cli是否安装成功及版本号"></a>查看vue-cli是否安装成功及版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V //注意V要大写，如果有版本号了则说明vue-cli安装成功了。</span><br></pre></td></tr></table></figure>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>​    1、动态路由匹配（/goodlists/:id）</p>
<p>​    2、嵌套路由(children)</p>
<p>​    3、编程式路由（js控制路由的跳转 this.$router.push()）</p>
<p>​    4、命名路由和命名视图 </p>
<p>​    命名路由：给路由定义不同的名字，根据名字进行匹配 :to={name:xx}</p>
<p>​        命名视图：给不同的router-view定义名字，通过名字进行对应组件的渲                                                                            染。<router-view name="xx"></router-view></p>
<h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><p>路由是根据不同的url地址展示不同的内容或页面。</p>
<p>前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的。</p>
<p>什么时候用？在单页应用中，大部分页面结构不变，只改变部分内容的使用。</p>
<h3 id="前端路由的优缺点"><a href="#前端路由的优缺点" class="headerlink" title="前端路由的优缺点"></a>前端路由的优缺点</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p>
<p>缺点：1、不利于seo。2、使用浏览器的前进，后退的时候会重新发送请求，没有合理地利用缓存。（正常的可利用浏览器的缓存机制直接前进后退而不用发送请求）</p>
<p>3、单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。</p>
<h3 id="前端路由的两种实现原理"><a href="#前端路由的两种实现原理" class="headerlink" title="前端路由的两种实现原理"></a>前端路由的两种实现原理</h3><p>1、History Api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此功能其实是对bom对象的history属性的封装。history.go(0) //刷新当前页</span><br><span class="line">history.go(1) history.forward()//前进 </span><br><span class="line">history.go(-1) history.back()//后退</span><br><span class="line">history.pushState(state,title,url);</span><br></pre></td></tr></table></figure>
<p>2、hash</p>
<p>我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理、Github 上各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。</p>
<p>根据监听哈希变化触发的事件 —— hashchange 事件。</p>
<p>两种方案推荐 hash 方案，因照顾到低级浏览器，就是不美观（url中多了一个 #）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    mode:&apos;history&apos;或&apos;hash&apos;, //vue中设置使用history还是hash的方法</span><br><span class="line">    routes:[]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="vue中的异步请求"><a href="#vue中的异步请求" class="headerlink" title="vue中的异步请求"></a>vue中的异步请求</h3><p>官方提供的vue-resource在vue2.0之后就不更新了，它提供了7个api和全局拦截器interceptors.不建议使用，流行使用地是扩展性比较好的axios，官方也推荐使用axios.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue-Resource中全局拦截器interceptors的使用</span><br><span class="line">Vue.http.interceptors.push((request,next)=&gt;&#123;</span><br><span class="line">    //请求发送前的处理逻辑，比如判断是否登录</span><br><span class="line">    //............</span><br><span class="line">    next((response)=&gt;&#123;</span><br><span class="line">        //请求发送后的处理逻辑</span><br><span class="line">        //.........</span><br><span class="line">        //根据请求的状态，response参数会返回给successCallback或errorCallback</span><br><span class="line">        return response;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="axios的全局拦截器"><a href="#axios的全局拦截器" class="headerlink" title="axios的全局拦截器"></a>axios的全局拦截器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use((config)=&gt;&#123;</span><br><span class="line">    console.log(&quot;request init!所有的请求之前都会走这里&quot;)</span><br><span class="line">    return config;</span><br><span class="line">&#125;);</span><br><span class="line">axios.interceptors.response.use((response)=&gt;&#123;//拦截响应的请求</span><br><span class="line">    console.log(&quot;response init&quot;);//打印之后才会响应请求，才会获得请求的数据</span><br><span class="line">    return response;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-模块化开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/15/模块化开发/" class="article-date">
      <time datetime="2018-02-15T06:12:39.000Z" itemprop="datePublished">2018-02-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/15/模块化开发/">AMD、CMD、CommonJs和ES6对比</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AMD是requireJs在推广过程中对模块定义的规范化产出，用法如下：</span><br><span class="line">define([&apos;package/lib&apos;],function(lib)&#123;</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        lib.sun(1,2);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo:foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">依赖前置，由国外团队出口，知名度比较高，用的也相对较多。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMD是SeaJs在推广过程中对模块定义的规范化产出，用法如下：</span><br><span class="line">//所有的模块都通过define来定义</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    </span><br><span class="line">    //通过require引入依赖</span><br><span class="line">    var $=require(&apos;jquery&apos;);//用的时候才引入</span><br><span class="line">&#125;)</span><br><span class="line">就近依赖，由淘宝团队打造，用的相对较少</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CommonJs规范-module.exports</span><br><span class="line">exports.sum=function(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES6特性 export/import</span><br><span class="line">export default&#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMD/CMD/ES6都是在前端模块化中用到。CommonJS是服务端模块化中用到，比如node.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-MVVM实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/MVVM实现原理/" class="article-date">
      <time datetime="2018-01-15T06:12:39.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/MVVM实现原理/">Mvvm实现原理学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="mvvm实现原理"><a href="#mvvm实现原理" class="headerlink" title="mvvm实现原理"></a>mvvm实现原理</h3><ol>
<li><p>Compile模板编译</p>
</li>
<li><p>Observer数据劫持</p>
</li>
<li><p>Watcher观察者</p>
</li>
<li><p>Dep发布订阅模式</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="http://oi28tswuq.bkt.clouddn.com/vue/mvvm.jpeg" alt="mvvm原理图"></p>
<h3 id="vue中实现双向绑定"><a href="#vue中实现双向绑定" class="headerlink" title="vue中实现双向绑定"></a>vue中实现双向绑定</h3></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index.html:</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input type=&apos;text&apos; v-model=&quot;message&quot;&gt;&lt;/input&gt;</span><br><span class="line">	&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;//先引入compile.js，因为mvvm.js依赖于compile.js,所以要先加载进来</span><br><span class="line">&lt;script src=&quot;MVVM.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let vm=new MVVM(&#123;</span><br><span class="line">        el:&apos;#app&apos;,也可写成document.getElementById(&quot;app&quot;);</span><br><span class="line">        data:&#123;</span><br><span class="line">            message1:&apos;hello yxn&apos;,</span><br><span class="line">            message:&#123;</span><br><span class="line">                a:1,</span><br><span class="line">                b:2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MVVM.JS:</span><br><span class="line">class MVVM&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //一开始先把可用的东西挂载到实例上</span><br><span class="line">        this.$el=options.el;</span><br><span class="line">        this.$data=options.data;</span><br><span class="line">        </span><br><span class="line">        //如果有要编译的模板就开始编译，用元素和数据进行编译。此处为了后续扩展，把编译封装成一个类。</span><br><span class="line">        if(this.$el)&#123;</span><br><span class="line">        	//数据劫持 就是把对象的所有属性改成get和set方法</span><br><span class="line">        	new Observer(this.$data);</span><br><span class="line">        	this.proxyData(this.$data);</span><br><span class="line">            new Compile(this.$el,this);//直接传入this，方便获取更多的数据(属性)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    proxyData(data)&#123;//代理数据，控制台直接用vm.xx获取数据，就不用使用vm.$data.xx来获取数据了。</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this,key,&#123;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return data[key];</span><br><span class="line">                &#125;,</span><br><span class="line">                set(newValue)&#123;</span><br><span class="line">                    return data[key]=newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">compile.js</span><br><span class="line">class Compile&#123;</span><br><span class="line">    constructor(el,vm)&#123;  //vm代表MVVM的当前实例</span><br><span class="line">        this.el=this.isElementNode(el)?el:document.querySelctor(el);</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        //如果这个元素能获取到，就开始编译</span><br><span class="line">        if(this.el)&#123;</span><br><span class="line">          1.先把这些真实的dom移入到内存中 fragment(避免频繁操作dom消耗性能)</span><br><span class="line">          let fragment=this.nodeTofragment(this.el);</span><br><span class="line">          2.编译=》提取想要的元素节点v-model和文本节点&#123;&#123;&#125;&#125;</span><br><span class="line">          this.compile(fragment);</span><br><span class="line">          3.把编译好的fragment在塞回到页面里去</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*用到的辅助方法*/</span><br><span class="line">    isDirective(name)&#123;</span><br><span class="line">        return name.includes(&apos;v-&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    isElementNode(node)&#123;</span><br><span class="line">        return node.nodeType===1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*用到的核心方法*/</span><br><span class="line">    compileElement(node)&#123;</span><br><span class="line">       //带v-model v-text,v-一系列</span><br><span class="line">        let attrs=node.attributes;</span><br><span class="line">        Array.form(attrs).forEach(attr=&gt;&#123;</span><br><span class="line">            //判断属性名字是不是包含v-   属性包含值和名</span><br><span class="line">            let attrName=attr.name;</span><br><span class="line">            if(this.isDirective(attrName))&#123; //取到对应的值放到节点中</span><br><span class="line">                let expr=attr.value; // node this.vm.$data expr</span><br><span class="line">                let [,type]=attrName.split(&apos;-&apos;);</span><br><span class="line">                CompileUtil[type](node,this.vm,expr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node)&#123;</span><br><span class="line">        //带&#123;&#123;&#125;&#125;</span><br><span class="line">        let text = node.textContent;//取文本中的内容</span><br><span class="line">        let reg=/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g;</span><br><span class="line">        if(reg.test(expr))&#123;</span><br><span class="line">            CompileUtil[&apos;text&apos;](node,this.vm,expr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    compile(fragment)&#123;</span><br><span class="line">        let childNodes=fragment.childNodes;//获取的元素不包括子节点</span><br><span class="line">        Array.from(childNodes).forEach(node=&gt;&#123;</span><br><span class="line">            if(this.isElementNode(node))&#123;//元素节点，还需要继续深入查找是否还有子节点。箭头函数没有this指向问题，都指向最外层。</span><br><span class="line">            	this.compileElement(node);</span><br><span class="line">                this.compile(node);</span><br><span class="line">            &#125;else&#123;//文本节点</span><br><span class="line">               this.compileText(node)； </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    nodeTofragment(el)&#123; //需要将el中的内容全部放到内存中</span><br><span class="line">       //文档碎片，不是真实的dom,是内存中的dom</span><br><span class="line">        let fragment =document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        while(firstChild=el.firstChild)&#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;//内存中的dom节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CompileUtil=&#123;</span><br><span class="line">	getVal(vm,expr)&#123; //获取实例上对应的数据</span><br><span class="line">        expr=expr.split(&apos;.&apos;);//[message,a,b]</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">	&#125;,</span><br><span class="line">	getTextVal(vm,expr)&#123; //获取编译后文本的结果</span><br><span class="line">        return expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            return this.getVal(vm,arguments[1]);</span><br><span class="line">        &#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">    text(node,vm,expr)&#123; //文本处理 &#123;&#123;a&#125;&#125;</span><br><span class="line">        let updateFn=this.updater[&apos;textUpdater&apos;];</span><br><span class="line">        //&#123;&#123;message.a&#125;&#125;=&gt;&apos;ywx&apos;</span><br><span class="line">        let value=this.getTextVal(vm,expr);</span><br><span class="line">        expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            new Watcher(vm,arguments[1],(newValue)=&gt;&#123;</span><br><span class="line">            	//如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容</span><br><span class="line">                updateFn&amp;&amp;updateFn(node,this.getTextVal(vm,expr));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    setVal(vm,expr,value)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next,currentIndex)=&gt;&#123;</span><br><span class="line">            if(currentIndex===expr.length-1)&#123;</span><br><span class="line">                return prev[next]=value;</span><br><span class="line">            &#125;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    model(node,vm,expr)&#123; //输入框处理</span><br><span class="line">        let updateFn=this.updater[&apos;modelUpdater&apos;];</span><br><span class="line">        //这里应该加一个监控，数据变化了应该调用这个watch的callback</span><br><span class="line">        new Watcher(vm,expr,(newValue)=&gt;&#123;</span><br><span class="line">        	//当值变化后会调用cb 将新的值传递过来</span><br><span class="line">             updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">        &#125;)</span><br><span class="line">        node.addEventListener(&apos;input&apos;,e=&gt;&#123;</span><br><span class="line">            let newValue =e.target.value;</span><br><span class="line">            this.setVal(vm,expr,newValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        textUpdater(node,value)&#123; //文本更新</span><br><span class="line">            node.textContent=value;</span><br><span class="line">        &#125;,</span><br><span class="line">        modelUpdater(node,value)&#123; //输入框更新</span><br><span class="line">            node.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">observer.js  </span><br><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data)&#123;</span><br><span class="line">        //要对这个data数据的所有属性改成set和get的形式</span><br><span class="line">        if(!data || typeof data !== &apos;object&apos;)&#123;//数据不存在或者数据不是对象，就不用劫持了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //要将数据一一劫持，先获取到data的key和value</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            //劫持</span><br><span class="line">            this.defineReactive(data,key,data[key])；</span><br><span class="line">            this.observer(data[key])//深度劫持</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //定义响应式</span><br><span class="line">    defineReactive(obj,key,value)&#123;</span><br><span class="line">        let that=this;</span><br><span class="line">        let dep=new Dep();//每个变化的数据，都会对应一个数组，这个数组存放所有更新的操作。</span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            enumerable:true,</span><br><span class="line">            configurable:true,</span><br><span class="line">            get()&#123;</span><br><span class="line">            	//获取属性值的时候可以todo.....</span><br><span class="line">            	Dep.target &amp;&amp;dep.addSub(Dep.target);</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">            set(newValue)&#123; </span><br><span class="line">            	//设置属性值的时候可以todo.....(做一些想做的事)</span><br><span class="line">                if(newValue != value)&#123;</span><br><span class="line">                	that.observer(newValue);//如果新值是对象还得继续劫持，这里面的this不是实例。</span><br><span class="line">                    value = newValue;</span><br><span class="line">                    dep.notify();//通知所有人，数据更新了。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dep&#123;</span><br><span class="line">    //发布订阅</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs=[];</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(watcher)&#123;</span><br><span class="line">        this.subs.push(watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(watcher=&gt;watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">watcher.js</span><br><span class="line">//观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法。</span><br><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(vm,expr,cb)&#123;</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        this.expr=expr;</span><br><span class="line">        this.cb=cb;</span><br><span class="line">        //先获取一下老值</span><br><span class="line">        this.value=this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    getVal(vm,expr)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">    &#125;</span><br><span class="line">    get()&#123;</span><br><span class="line">    	Dep.target=this;</span><br><span class="line">        let value=this.getVal(this.vm,this.expr);</span><br><span class="line">        Dep.target=null;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //对外暴露的方法</span><br><span class="line">    update()&#123;</span><br><span class="line">        let newValue=this.getVal(this.vm,this.expr);</span><br><span class="line">        let oldValue=this.value;</span><br><span class="line">        if(newValue != oldValue)&#123;</span><br><span class="line">            this.cb(newValue);//对应watch的callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用新值和老值进行对比，如果发生变化，就调用更新方法</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue、mvvm/">vue、mvvm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jsjicheng" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/jsjicheng/" class="article-date">
      <time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/jsjicheng/">js中的继承方式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getX = function ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function B()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</span><br><span class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</span><br></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">    this.x = 100; //d.x = 100</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function D()&#123;</span><br><span class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function E()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">E.prototype.getX = function ()&#123;&#125;</span><br><span class="line">function F()&#123;</span><br><span class="line">    var e = new E(); //e.x = 100;</span><br><span class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</span><br><span class="line">        //attr = x</span><br><span class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</span><br><span class="line">            this[attr] = e[attr];</span><br><span class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</span><br><span class="line">        &#125;</span><br><span class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function G()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">G.prototype.getX = function()&#123;&#125;;</span><br><span class="line">function H()&#123;</span><br><span class="line">    G.call(this);</span><br><span class="line">&#125;</span><br><span class="line">H.prototype = new G();</span><br><span class="line">H.prototype.constructor = H;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function K()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">k.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function M()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</span><br></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.name = &quot;ywx&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">//寄生组合式继承实现方式如下：</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">var child=new Child();</span><br><span class="line">console.log(child.eat());//只有找到父类原型上的方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js继承、原型链/">js继承、原型链</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-windows" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/28/nginx-windows/" class="article-date">
      <time datetime="2017-04-28T08:50:18.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/nginx-windows/">Windows下Nginx的启动、停止等命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。</p>
<h4 id="1、启动："><a href="#1、启动：" class="headerlink" title="1、启动："></a>1、启动：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;start nginx</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe</div></pre></td></tr></table></figure>
<p>注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。</p>
<h4 id="2、停止："><a href="#2、停止：" class="headerlink" title="2、停止："></a>2、停止：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s stop</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s quit</div></pre></td></tr></table></figure>
<p>注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。</p>
<h4 id="3、重新载入Nginx："><a href="#3、重新载入Nginx：" class="headerlink" title="3、重新载入Nginx："></a>3、重新载入Nginx：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reload</div></pre></td></tr></table></figure>
<p>当配置信息修改，需要重新载入这些配置时使用此命令。不重新启动不会生效。</p>
<h4 id="4、重新打开日志文件："><a href="#4、重新打开日志文件：" class="headerlink" title="4、重新打开日志文件："></a>4、重新打开日志文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reopen</div></pre></td></tr></table></figure>
<h4 id="5、查看Nginx版本："><a href="#5、查看Nginx版本：" class="headerlink" title="5、查看Nginx版本："></a>5、查看Nginx版本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx -v</div></pre></td></tr></table></figure>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>注：以上C:\server\nginx-1.0.2需要改成自已nginx的安装目录。每次写路径太麻烦，可以把C:\server\nginx-1.0.2配置成环境变量，这样就不用每次都写路径了，在任意目录下打开git或者cmd直接执行命令，系统会自己在环境变量path中查找。在此做下特殊说明：window下就算nginx配置好了环境变量，有些命令（比如：nginx -s stop）也无法用，会报错。</p>
<p>一、在cmd中，逐步进入到nginx的安装目录，在此目录下执行那些命令都可以。一步步进安装目录如果麻烦，可以执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start /D E:\nginx\nginx-1.6.2 nginx -s start</div><div class="line">Windows下的话可以用start命令，/D参数指定起始目录，这样在执行nginx命令前重新设定了指定的目录。</div></pre></td></tr></table></figure></p>
<p>此时会cmd会自动把路径跳转到nginx的安装目录了，此时也可以执行命令了。</p>
<p>二、也可以在安装目录下打开git,输入./nginx按回车，即启动了nginx,再按ctrl+c关闭nginx.</p>
<p>三、可以双击nginx.exe启动nginx,当修改了nginx.conf配置文件时，此时要重启，先在任务管理器中结束nginx的进程（打开任务管理器，输入英文字母n，可以快速定位到以n开头的应用，方便查找了），然后在双击运行nginx。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-configuration-start" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/nginx-configuration-start/" class="article-date">
      <time datetime="2017-04-26T08:34:27.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/nginx-configuration-start/">Nginx 配置简述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>不论是本地开发，还是远程到 Server 开发，还是给提供 demo 给人看效果，我们时常需要对 Nginx 做配置，Nginx 的配置项相当多，如果考虑性能配置起来会比较麻烦。不过，我们往往只是需要一个静态 Server，或者一个反向代理 Server，这对 Nginx 来说小菜一碟。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Nginx 的安装就不解释了，方便起见，也可以在各平台可以直接执行对应安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># CentOS</div><div class="line">yum install nginx;</div><div class="line"># Ubuntu</div><div class="line">sudo apt-get install nginx;</div><div class="line"># Mac</div><div class="line">brew install nginx;</div></pre></td></tr></table></figure></p>
<p>常用的设置一般可以在 /etc/nginx/nginx.conf 中配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">下面是linux下的启动参数（windows的启动命令和其不一样）：</div><div class="line"># 启动</div><div class="line">nginx -s start;</div><div class="line"># 重新启动，热启动，修改配置重启不影响线上</div><div class="line">nginx -s reload;</div><div class="line"># 关闭</div><div class="line">nginx -s stop;</div><div class="line"># 修改配置后，可以通过下面的命令测试是否有语法错误</div><div class="line">nginx -t;</div></pre></td></tr></table></figure></p>
<p>-s，signal，意思就是向 nginx 发送 start|reload|stop 命令，还是很好理解的。先看一个最简单的 nginx.conf 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 需要保留这一个段落，可以为空</div><div class="line">    # 为注释的意思</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        location / &#123;</div><div class="line">            root /home/webywx/test/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动后，访问 <a href="http://127.0.0.1:8888" target="_blank" rel="external">http://127.0.0.1:8888</a> ，如果 /home/webywx/test/ 下有 index.html 文件就会展示 index.html 的内容，否则返回 404。</p>
<h4 id="Nginx-配置一个-Web-服务器"><a href="#Nginx-配置一个-Web-服务器" class="headerlink" title="Nginx 配置一个 Web 服务器"></a>Nginx 配置一个 Web 服务器</h4><p>以下是对配置 Web 服务器的参数做简单说明，包括如何配置端口、域名，如何处理请求，如何响应请求。</p>
<p>1、 虚拟主机和请求的分发<br>域名和端口的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">listen 127.0.0.1:8000;</div><div class="line">listen *:8000;</div><div class="line">listen localhost:8000;</div><div class="line"># IPV6</div><div class="line">listen [::]:8000;</div><div class="line"># other params</div><div class="line">listen 443 default_serer ssl;</div><div class="line">listen 127.0.0.1 default_server accept_filter=dataready backlog=1024</div></pre></td></tr></table></figure></p>
<p>主机名配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server_name www.webywx.com webywx.com</div><div class="line">server_name *.webywx.com</div><div class="line">server_name ~^\.web\.com$</div></pre></td></tr></table></figure></p>
<p>URI 匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location = / &#123;</div><div class="line">    # 完全匹配  =</div><div class="line">    # 大小写敏感 ~</div><div class="line">    # 忽略大小写 ~*</div><div class="line">&#125;</div><div class="line">location ^~ /images/ &#123;</div><div class="line">    # 前半部分匹配 ^~</div><div class="line">    # 可以使用正则，如：</div><div class="line">    # location ~* \.(gif|jpg|png)$ &#123; &#125;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 如果以上都未匹配，会进入这里</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 文件路径的定义<br>根目录设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root /home/webywx/test/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>别名设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    alias /home/webywx/www/blog/;</div><div class="line">&#125;</div><div class="line">location ~ ^/blog/(\d+)/([\w-]+)$ &#123;</div><div class="line">    alias /home/webywx/www/blog/$1-$2.md;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首页设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index /html/index.html /php/index.php;</div></pre></td></tr></table></figure></p>
<p>重定向页面设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">error_page    404         /404.html;</div><div class="line">error_page    502  503    /50x.html;</div><div class="line">error_page    404  =200   /1x1.gif;</div><div class="line">location / &#123;</div><div class="line">    error_page  404 @fallback;</div><div class="line">&#125;</div><div class="line">location @fallback &#123;</div><div class="line">    # 将请求反向代理到上游服务器处理</div><div class="line">    proxy_pass http://localhost:9000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>try_files 设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try_files $uri $uri.html $uri/index.html @other;</div><div class="line">location @other &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，失败了就会转到上游处理</div><div class="line">    proxy_pass  http://localhost:9000;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，没找到直接返回 502</div><div class="line">    try_files $uri $uri.html =502;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx-配置反向代理服务器"><a href="#Nginx-配置反向代理服务器" class="headerlink" title="Nginx 配置反向代理服务器"></a>Nginx 配置反向代理服务器</h4><p>反向代理（reserve proxy）方式是指用代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络中的上游服务器，并将上游服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外的表现就是一个 Web 服务器。</p>
<p>Nginx 具备超强的高并发高负载能力，一般会作为前端的服务器直接向客户端提供静态文件服务；而业务一般还包含一些业务逻辑需要 Apache、Tomcat 等服务器来处理，故通常 Nginx 对外表现即为静态 Web 服务器也是反向代理服务器。</p>
<p>缺点是增加了一次请求的处理时间，优点是降低了上游服务器的负载，尽量将压力放在 Nginx 服务器上。</p>
<p>1、负载均衡配置<br>upstream，定义一个上游服务器集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    # ip_hash;</div><div class="line">    server s1.webywx.com;</div><div class="line">    server s2.webywx.com;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://backend;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、反向代理<br>proxy_pass 将请求转发到有处理能力的端上，默认不会转发请求中的 Host 头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    prox_pass http://localhost:9000;</div><div class="line">    ### 下面都是次要关注项</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_method POST;</div><div class="line">    # 指定不转发的头部字段</div><div class="line">    proxy_hide_header Cache-Control;</div><div class="line">    proxy_hide_header Other-Header;</div><div class="line">    # 指定转发的头部字段</div><div class="line">    proxy_pass_header Server-IP;</div><div class="line">    proxy_pass_header Server-Name;</div><div class="line">    # 是否转发包体</div><div class="line">    proxy_pass_request_body on | off;</div><div class="line">    # 是否转发头部</div><div class="line">    proxy_pass_request_headers on | off;</div><div class="line">    # 显形/隐形 URI，上游发生重定向时，Nginx 是否同步更改 uri</div><div class="line">    proxy_redirect on | off;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="一个简单的例子，Node-js"><a href="#一个简单的例子，Node-js" class="headerlink" title="一个简单的例子，Node.js"></a>一个简单的例子，Node.js</h4><p>一个十分常见的需求：处理请求，如果是静态文件，Nginx 直接返回，否则交给 Node 服务器处理。首先创建了一个 Node 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line">http.createServer((req, res) =&gt; &#123;</div><div class="line">    res.end(&apos;hello world&apos;);</div><div class="line">&#125;).listen(9000);</div></pre></td></tr></table></figure></p>
<p>任何请求过来都返回 hello world，简版的 Nginx 配置如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 这里可不写东西</div><div class="line">    use epoll;</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">        try_files $uri $uri/index.html;</div><div class="line">        location ~* ^/(js|css|image|font)/$ &#123;</div><div class="line">            # 静态资源都在 static 文件夹下</div><div class="line">            root /home/webywx/www/static/;</div><div class="line">        &#125;</div><div class="line">        location /app &#123;</div><div class="line">            # Node.js 在 9000 开了一个监听端口</div><div class="line">            proxy_pass http://127.0.0.1:9000;</div><div class="line">        &#125;</div><div class="line">        # 上面处理出错或者未找到的，返回对应状态码文件</div><div class="line">        error_page    404            /404.html;</div><div class="line">        error_page    502  503  504  /50x.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先 try_files，尝试直接匹配文件；没找到就匹配静态资源；还没找到就交给 Node 处理；否则就返回 4xx/5xx 的状态码。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>边学边动手尝试，利用 nginx -t 测试语法，遇到问题就 Google 搜索下，上手应该还是很快的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-interview-css" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/interview-css/" class="article-date">
      <time datetime="2017-04-26T07:10:31.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/interview-css/">前端笔试面试中的常用到的CSS知识点总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成积累的习惯。</p>
<h4 id="1、CSS选择器的优先级"><a href="#1、CSS选择器的优先级" class="headerlink" title="1、CSS选择器的优先级"></a>1、CSS选择器的优先级</h4><p>!important &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器<br>多个类选择器叠加（256）之后的优先级大于一个id选择器<br>!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。<br>CSS选择器的种类：<br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p>
<h4 id="2、CSS优先级权重计算法"><a href="#2、CSS优先级权重计算法" class="headerlink" title="2、CSS优先级权重计算法"></a>2、CSS优先级权重计算法</h4><p>CSS优先级的计算规则如下：<br>元素标签中定义的样式（Style属性）,加1,0,0,0<br>每个ID选择符(如 #id),加0,1,0,0<br>每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0<br>每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1<br>然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值<br>然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。<br>前一等级相等才往后比，依次类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">例如果样式中有两个id选择符，则为0,2,0,0;</div><div class="line">#div1 #div2&#123;</div><div class="line">color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"><a href="#3、超链接访问过后hover样式就不出现的问题是什么？如何解决？" class="headerlink" title="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"></a>3、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h4><p>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）,为了便于记忆，可以记love hate;</p>
<h4 id="4、什么是Css-Hack？ie6-7-8的hack分别是什么？"><a href="#4、什么是Css-Hack？ie6-7-8的hack分别是什么？" class="headerlink" title="4、什么是Css Hack？ie6,7,8的hack分别是什么？"></a>4、什么是Css Hack？ie6,7,8的hack分别是什么？</h4><p>针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#test   &#123;   </div><div class="line">        width:300px;   </div><div class="line">        height:300px;   </div><div class="line">        background-color:blue;      /*firefox*/</div><div class="line">        background-color:red\9;      /*all ie*/</div><div class="line">        background-color:yellow\0;    /*ie8*/</div><div class="line">        +background-color:pink;        /*ie7*/</div><div class="line">        _background-color:orange;       /*ie6*/    &#125;  </div><div class="line">        :root #test &#123; background-color:purple\9; &#125;  /*ie9*/</div><div class="line">    @media all and (min-width:0px)&#123; </div><div class="line">          #test &#123;background-color:black\0;&#125; </div><div class="line">     &#125;  /*opera*/</div><div class="line">    @media screen and (-webkit-min-device-pixel-ratio:0)&#123; </div><div class="line">#test &#123;background-color:gray;&#125; </div><div class="line">&#125;       /*chrome and safari*/</div></pre></td></tr></table></figure></p>
<h4 id="5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？"><a href="#5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？" class="headerlink" title="5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？"></a>5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h4><p>不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。<br>你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p>
<h4 id="6、display-none与visibility-hidden的区别是什么？"><a href="#6、display-none与visibility-hidden的区别是什么？" class="headerlink" title="6、display:none与visibility:hidden的区别是什么？"></a>6、display:none与visibility:hidden的区别是什么？</h4><p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br>即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>
<h4 id="7、CSS盒子模型"><a href="#7、CSS盒子模型" class="headerlink" title="7、CSS盒子模型"></a>7、CSS盒子模型</h4><p>Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。</p>
<p><div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/box-model.png-public" alt=""><br></div><br>如上图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分，这就是标准的盒模型（它的宽高就是指content区）。但盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box），IE盒模型又称怪异盒模型（它的宽高包含border、内边距和content）。</p>
<h4 id="8、相对定位relative、浮动float以及绝对定位absolute的区别？"><a href="#8、相对定位relative、浮动float以及绝对定位absolute的区别？" class="headerlink" title="8、相对定位relative、浮动float以及绝对定位absolute的区别？"></a>8、相对定位relative、浮动float以及绝对定位absolute的区别？</h4><p>1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。<br>2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。<br>3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。</p>
<h4 id="9、清除浮动的用法？"><a href="#9、清除浮动的用法？" class="headerlink" title="9、清除浮动的用法？"></a>9、清除浮动的用法？</h4><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br>使用方法：<br>1、在浮动元素后使用一个空元素如<br>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。<br>2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动<br>3、什么都不做，给浮动元素后面的元素添加clear属性。<br>4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//一种常见利用伪类清除浮动的代码</div><div class="line"> .clearfix:after &#123;</div><div class="line">    content:&quot;.&quot;;       //这里利用到了content属性</div><div class="line">    display:block; </div><div class="line">    height:0;</div><div class="line">    visibility:hidden; </div><div class="line">    clear:both; </div><div class="line">&#125;</div><div class="line">.clearfix &#123; </div><div class="line">    *zoom:1; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"><a href="#10、BOX模型的margin在IE比在其他浏览器大2px的解决办法" class="headerlink" title="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"></a>10、BOX模型的margin在IE比在其他浏览器大2px的解决办法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div&#123;margin:30px!important;margin:28px;&#125;</div></pre></td></tr></table></figure>
<p>注意这两个margin的顺序一定不能写反，!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：<br>div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;<br>也可以用hack写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div &#123; _margin:28px;margin:28px\9;margin:30px;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="11、IE-3像素Bug的产生原因及解决办法"><a href="#11、IE-3像素Bug的产生原因及解决办法" class="headerlink" title="11、IE 3像素Bug的产生原因及解决办法"></a>11、IE 3像素Bug的产生原因及解决办法</h4><p>当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。<br>解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。</p>
<h4 id="12、IE6-双边距Bug的产生原因及解决办法"><a href="#12、IE6-双边距Bug的产生原因及解决办法" class="headerlink" title="12、IE6 双边距Bug的产生原因及解决办法"></a>12、IE6 双边距Bug的产生原因及解决办法</h4><p>当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。<br>解决办法：添加_display:inline</p>
<h4 id="13、文本溢出省略的处理方法"><a href="#13、文本溢出省略的处理方法" class="headerlink" title="13、文本溢出省略的处理方法"></a>13、文本溢出省略的处理方法</h4><p>1)单行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.inline&#123;</div><div class="line">  overflow:hidden;</div><div class="line">         white-space:nowrap;</div><div class="line">         text-overflow:ellipsis; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)多行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.foo&#123;</div><div class="line">  display:-webkit-box!important;</div><div class="line">  overflow:hidden;</div><div class="line">  text-overflow:ellipsis;</div><div class="line">  work-break:break-all;</div><div class="line">  -webkit-box-orient:vertical; /*方向*/</div><div class="line">  -webkit-line-clamp:4; /*显示多少行文本*/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。</p>
<h4 id="14、CSS实现垂直水平居中"><a href="#14、CSS实现垂直水平居中" class="headerlink" title="14、CSS实现垂直水平居中"></a>14、CSS实现垂直水平居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">.parent &#123;</div><div class="line">          width:800px;</div><div class="line">          height:500px;</div><div class="line">          border:2px solid #000;</div><div class="line">          position:relative;</div><div class="line">&#125;</div><div class="line"> .child &#123;</div><div class="line">        width:200px;</div><div class="line">        height:200px;</div><div class="line">        margin: auto;  </div><div class="line">        position: absolute;  </div><div class="line">        top: 0; left: 0; bottom: 0; right: 0; </div><div class="line">        background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法2：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:table-cell;</div><div class="line">    vertical-align:middle;</div><div class="line">    text-align: center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    display:inline-block;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">方法3：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:flex;</div><div class="line">    justify-content:center;</div><div class="line">    align-items:center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">方法4：</div><div class="line">.parent &#123;</div><div class="line">        width:800px;</div><div class="line">        height:500px;</div><div class="line">        border:2px solid #000;</div><div class="line">        position:relative;</div><div class="line">    &#125;</div><div class="line">.child &#123;</div><div class="line">    width:300px;</div><div class="line">    height:200px;</div><div class="line">    margin:auto;</div><div class="line">    position:absolute;</div><div class="line">//设定水平和垂直偏移父元素的50%，</div><div class="line">//再根据实际长度将子元素上左挪回一半大小</div><div class="line">    left:50%;</div><div class="line">    top:50%;</div><div class="line">    margin-left: -150px;</div><div class="line">    margin-top:-100px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="15、BFC"><a href="#15、BFC" class="headerlink" title="15、BFC"></a>15、BFC</h4><p>块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。<br>BFC的创建方法：<br>根元素或其它包含它的元素；<br>浮动 (元素的float不为none)；<br>绝对定位元素 (元素的position为absolute或fixed)；<br>行内块inline-blocks(元素的 display: inline-block)；<br>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；<br>overflow的值不为visible的元素；<br>弹性盒 flex boxes (元素的display: flex或inline-flex)；</p>
<h4 id="16、响应式图片的CSS"><a href="#16、响应式图片的CSS" class="headerlink" title="16、响应式图片的CSS"></a>16、响应式图片的CSS</h4><p>所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">width:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">max-width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="17、CSS响应式网格系统原理"><a href="#17、CSS响应式网格系统原理" class="headerlink" title="17、CSS响应式网格系统原理"></a>17、CSS响应式网格系统原理</h4><p>总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    box-sizing: border-box;</div><div class="line">&#125;</div><div class="line">[class*=&quot;col-&quot;] &#123;</div><div class="line">    float: left;</div><div class="line">    padding: 15px;</div><div class="line">    border: 1px solid red;</div><div class="line">&#125;</div><div class="line">.col-1 &#123;width: 8.33%;&#125;</div><div class="line">.col-2 &#123;width: 16.66%;&#125;</div><div class="line">.col-3 &#123;width: 25%;&#125;</div><div class="line">.col-4 &#123;width: 33.33%;&#125;</div><div class="line">.col-5 &#123;width: 41.66%;&#125;</div><div class="line">.col-6 &#123;width: 50%;&#125;</div><div class="line">.col-7 &#123;width: 58.33%;&#125;</div><div class="line">.col-8 &#123;width: 66.66%;&#125;</div><div class="line">.col-9 &#123;width: 75%;&#125;</div><div class="line">.col-10 &#123;width: 83.33%;&#125;</div><div class="line">.col-11 &#123;width: 91.66%;&#125;</div><div class="line">.col-12 &#123;width: 100%;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="18、用LESS循环实现栅格类"><a href="#18、用LESS循环实现栅格类" class="headerlink" title="18、用LESS循环实现栅格类"></a>18、用LESS循环实现栅格类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.generate-columns(12);</div><div class="line">.generate-columns(@n; @i: 1) when (@i =&lt; @n) &#123;</div><div class="line">  .column-@&#123;i&#125; &#123;</div><div class="line">    width: (@i * 100% / @n);</div><div class="line">  &#125;</div><div class="line">.generate-columns(@n, (@i + 1));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="19、使用perspective属性和transform：perspective-函数的区别"><a href="#19、使用perspective属性和transform：perspective-函数的区别" class="headerlink" title="19、使用perspective属性和transform：perspective()函数的区别"></a>19、使用perspective属性和transform：perspective()函数的区别</h4><p>以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。<br>perspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)<br>transform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br>backface-visibility：hidden|visibility设置背后元素是否可见</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-前端开发/">css 前端开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-flexintroduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/20/flexintroduction/" class="article-date">
      <time datetime="2017-02-20T03:09:43.000Z" itemprop="datePublished">2017-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/20/flexintroduction/">学习flex布局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<h4 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行内元素也可以使用Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Webkit内核的浏览器，必须加上-webkit前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: -webkit-flex; /* Safari */</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h4><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h4 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h4><p>以下6个属性设置在容器上。<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>
<p>更多学习内容参考以下链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex-css3/">flex css3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Wenxi Yan
            </div>
            <div class="footer-right">
                <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >用户到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>