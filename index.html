<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人博客">
<meta property="og:url" content="http://yanwenxi.github.io/index.html">
<meta property="og:site_name" content="闫文喜的个人博客">
<meta property="og:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人博客">
<meta name="twitter:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Wenxi Yan</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">我的小窝</a></li>
                        
                            <li><a href="/archives">文章列表</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                            
                                <a class="fl wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-前端开发/" style="font-size: 10px;">css 前端开发</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css3/" style="font-size: 10px;">flex css3</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/i18n/" style="font-size: 10px;">i18n</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试-Benchmark-jsPerf/" style="font-size: 10px;">js 性能调试 Benchmark jsPerf</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/js继承、原型链/" style="font-size: 10px;">js继承、原型链</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/nginx/" style="font-size: 12.5px;">nginx</a> <a href="/tags/node/" style="font-size: 12.5px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 20px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/promise、es6/" style="font-size: 10px;">promise、es6</a> <a href="/tags/rap/" style="font-size: 17.5px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 20px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/vue、mvvm/" style="font-size: 10px;">vue、mvvm</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 15px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端工程-构建工具-前端开发/" style="font-size: 10px;">前端工程 构建工具 前端开发</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com">前端小站</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://ywxi.github.io/">web博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">运动健身、网络营销、web前端、喜欢接触新鲜事物、迎接新的挑战</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Wenxi Yan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Wenxi Yan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">我的小窝</a></li>
                
                    <li><a href="/archives">文章列表</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/15/Promise/" class="article-date">
      <time datetime="2018-05-15T06:12:39.000Z" itemprop="datePublished">2018-05-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/15/Promise/">promise学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h3><p>Promise 是异步编程的一种解决方案，它有三种状态，分别是pending(进行中)、</p>
<p>resolved(已完成)、rejected(已失败)。</p>
<p>当Promsie的状态由pending转变成resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是Promise-承诺名字的由来。</p>
<h3 id="ES6之前的promise"><a href="#ES6之前的promise" class="headerlink" title="ES6之前的promise"></a>ES6之前的promise</h3><p>使用较为成熟的第三方promise库—<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">Bluebird</a></p>
<h3 id="ES6的promise-基本使用方法"><a href="#ES6的promise-基本使用方法" class="headerlink" title="ES6的promise 基本使用方法"></a>ES6的promise 基本使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    if(success)&#123;</span><br><span class="line">        resolve(successData)//pending=&gt;resolved,参数传递给对应的回调方法</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject(failData) //pending=&gt;rejected,参数传递给对应的回调方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">注：实例化的Promsie对象会立即执行。</span><br></pre></td></tr></table></figure>
<h3 id="then-和catch-方法"><a href="#then-和catch-方法" class="headerlink" title="then()和catch()方法"></a>then()和catch()方法</h3><p>Promise.prototype.then()是Promise原型链上的方法，它有两个参数(都是函数)，分别对应resolved的回调和rejected的回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    (successData) =&gt; &#123; console.log(&apos;我是成功的回调参数是successData&apos;) &#125;,</span><br><span class="line">    (failData) =&gt; &#123; console.log(&apos;我是失败的回调参数是failData&apos;) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>.catch()也是原型链上的方法，作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>同样，catch()中也可以抛出错误，由于抛出的错误会在下一个catch中被捕获处理，因此可以再添加catch()；</p>
<p>当状态已经改变为resolved后，即使抛出错误，也不会触发then()的错误回调或者catch()方法；</p>
<p>then() 和 catch() 都会返回一个新的Promise对象，可以链式调用；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">    () =&gt; &#123; console.log(&apos;this is success callback&apos;) &#125;</span><br><span class="line">).catch(</span><br><span class="line">    (err) =&gt; &#123; console.log(err) &#125;</span><br><span class="line">).then(</span><br><span class="line">    ...</span><br><span class="line">).catch(</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Promise实例的异步方法和then-中返回promise有什么区别？"><a href="#Promise实例的异步方法和then-中返回promise有什么区别？" class="headerlink" title="Promise实例的异步方法和then()中返回promise有什么区别？"></a>Promise实例的异步方法和then()中返回promise有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// p1异步方法中返回p2</span><br><span class="line">let p1 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(p2)</span><br><span class="line">&#125; )</span><br><span class="line">let p2 = new Promise ( ... )</span><br><span class="line"></span><br><span class="line">// then()中返回promise</span><br><span class="line">let p3 = new Promise ( (resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125; )</span><br><span class="line">let p4 = new Promise ( ... )</span><br><span class="line">p3.then(</span><br><span class="line">    () =&gt; return p4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>p1异步方法中返回p2</strong></p>
<p>p1的状态取决于p2，如果p2为pending，p1将等待p2状态的改变，p2的状态一旦改变，p1将会立即执行自己对应的回调，即then()中的方法针对的依然是p1</p>
<p><strong>then()中返回promise</strong></p>
<p>由于then()本身就会返回一个新的promise，所以后一个then()针对的永远是一个新的promise，但是像上面代码中我们自己手动返回p4，那么我们就可以在返回的promise中再次通过 resolve() 和 reject() 来改变状态</p>
<h3 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h3><p>用来包装一个现有对象，将其转变为Promise对象，但Promise.resolve()会根据参数情况返回不同的Promise：</p>
<p><strong>参数是Promise</strong>：原样返回<br><strong>参数带有then方法</strong>：转换为Promise后立即执行then方法<br><strong>参数不带then方法、不是对象或没有参数</strong>：返回resolved状态的Promise</p>
<p>Promise.reject()会直接返回rejected状态的Promise;</p>
<h3 id="其他api"><a href="#其他api" class="headerlink" title="其他api"></a>其他api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.race([promise1,promise2,promise3,promise4....])</span><br><span class="line">Promise.done()/Promise.finally()</span><br><span class="line">//上述这几个api根据api名字自己脑补吧，娃哈哈。。。</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise、es6/">promise、es6</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-MVVM实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/15/MVVM实现原理/" class="article-date">
      <time datetime="2018-01-15T06:12:39.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/MVVM实现原理/">Mvvm实现原理学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="mvvm实现原理"><a href="#mvvm实现原理" class="headerlink" title="mvvm实现原理"></a>mvvm实现原理</h3><ol>
<li><p>Compile模板编译</p>
</li>
<li><p>Observer数据劫持</p>
</li>
<li><p>Watcher观察者</p>
</li>
<li><p>Dep发布订阅模式</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="http://oi28tswuq.bkt.clouddn.com/vue/mvvm.jpeg" alt="mvvm原理图"></p>
<h3 id="vue中实现双向绑定"><a href="#vue中实现双向绑定" class="headerlink" title="vue中实现双向绑定"></a>vue中实现双向绑定</h3></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index.html:</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input type=&apos;text&apos; v-model=&quot;message&quot;&gt;&lt;/input&gt;</span><br><span class="line">	&#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;compile.js&quot;&gt;&lt;/script&gt;//先引入compile.js，因为mvvm.js依赖于compile.js,所以要先加载进来</span><br><span class="line">&lt;script src=&quot;MVVM.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let vm=new MVVM(&#123;</span><br><span class="line">        el:&apos;#app&apos;,也可写成document.getElementById(&quot;app&quot;);</span><br><span class="line">        data:&#123;</span><br><span class="line">            message1:&apos;hello yxn&apos;,</span><br><span class="line">            message:&#123;</span><br><span class="line">                a:1,</span><br><span class="line">                b:2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MVVM.JS:</span><br><span class="line">class MVVM&#123;</span><br><span class="line">    constructor(options)&#123;</span><br><span class="line">        //一开始先把可用的东西挂载到实例上</span><br><span class="line">        this.$el=options.el;</span><br><span class="line">        this.$data=options.data;</span><br><span class="line">        </span><br><span class="line">        //如果有要编译的模板就开始编译，用元素和数据进行编译。此处为了后续扩展，把编译封装成一个类。</span><br><span class="line">        if(this.$el)&#123;</span><br><span class="line">        	//数据劫持 就是把对象的所有属性改成get和set方法</span><br><span class="line">        	new Observer(this.$data);</span><br><span class="line">        	this.proxyData(this.$data);</span><br><span class="line">            new Compile(this.$el,this);//直接传入this，方便获取更多的数据(属性)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    proxyData(data)&#123;//代理数据，控制台直接用vm.xx获取数据，就不用使用vm.$data.xx来获取数据了。</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            Object.defineProperty(this,key,&#123;</span><br><span class="line">                get()&#123;</span><br><span class="line">                    return data[key];</span><br><span class="line">                &#125;,</span><br><span class="line">                set(newValue)&#123;</span><br><span class="line">                    return data[key]=newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">compile.js</span><br><span class="line">class Compile&#123;</span><br><span class="line">    constructor(el,vm)&#123;  //vm代表MVVM的当前实例</span><br><span class="line">        this.el=this.isElementNode(el)?el:document.querySelctor(el);</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        //如果这个元素能获取到，就开始编译</span><br><span class="line">        if(this.el)&#123;</span><br><span class="line">          1.先把这些真实的dom移入到内存中 fragment(避免频繁操作dom消耗性能)</span><br><span class="line">          let fragment=this.nodeTofragment(this.el);</span><br><span class="line">          2.编译=》提取想要的元素节点v-model和文本节点&#123;&#123;&#125;&#125;</span><br><span class="line">          this.compile(fragment);</span><br><span class="line">          3.把编译好的fragment在塞回到页面里去</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*用到的辅助方法*/</span><br><span class="line">    isDirective(name)&#123;</span><br><span class="line">        return name.includes(&apos;v-&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    isElementNode(node)&#123;</span><br><span class="line">        return node.nodeType===1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*用到的核心方法*/</span><br><span class="line">    compileElement(node)&#123;</span><br><span class="line">       //带v-model v-text,v-一系列</span><br><span class="line">        let attrs=node.attributes;</span><br><span class="line">        Array.form(attrs).forEach(attr=&gt;&#123;</span><br><span class="line">            //判断属性名字是不是包含v-   属性包含值和名</span><br><span class="line">            let attrName=attr.name;</span><br><span class="line">            if(this.isDirective(attrName))&#123; //取到对应的值放到节点中</span><br><span class="line">                let expr=attr.value; // node this.vm.$data expr</span><br><span class="line">                let [,type]=attrName.split(&apos;-&apos;);</span><br><span class="line">                CompileUtil[type](node,this.vm,expr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node)&#123;</span><br><span class="line">        //带&#123;&#123;&#125;&#125;</span><br><span class="line">        let text = node.textContent;//取文本中的内容</span><br><span class="line">        let reg=/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g;</span><br><span class="line">        if(reg.test(expr))&#123;</span><br><span class="line">            CompileUtil[&apos;text&apos;](node,this.vm,expr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    compile(fragment)&#123;</span><br><span class="line">        let childNodes=fragment.childNodes;//获取的元素不包括子节点</span><br><span class="line">        Array.from(childNodes).forEach(node=&gt;&#123;</span><br><span class="line">            if(this.isElementNode(node))&#123;//元素节点，还需要继续深入查找是否还有子节点。箭头函数没有this指向问题，都指向最外层。</span><br><span class="line">            	this.compileElement(node);</span><br><span class="line">                this.compile(node);</span><br><span class="line">            &#125;else&#123;//文本节点</span><br><span class="line">               this.compileText(node)； </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    nodeTofragment(el)&#123; //需要将el中的内容全部放到内存中</span><br><span class="line">       //文档碎片，不是真实的dom,是内存中的dom</span><br><span class="line">        let fragment =document.createDocumentFragment();</span><br><span class="line">        let firstChild;</span><br><span class="line">        while(firstChild=el.firstChild)&#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;//内存中的dom节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CompileUtil=&#123;</span><br><span class="line">	getVal(vm,expr)&#123; //获取实例上对应的数据</span><br><span class="line">        expr=expr.split(&apos;.&apos;);//[message,a,b]</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">	&#125;,</span><br><span class="line">	getTextVal(vm,expr)&#123; //获取编译后文本的结果</span><br><span class="line">        return expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            return this.getVal(vm,arguments[1]);</span><br><span class="line">        &#125;)</span><br><span class="line">	&#125;,</span><br><span class="line">    text(node,vm,expr)&#123; //文本处理 &#123;&#123;a&#125;&#125;</span><br><span class="line">        let updateFn=this.updater[&apos;textUpdater&apos;];</span><br><span class="line">        //&#123;&#123;message.a&#125;&#125;=&gt;&apos;ywx&apos;</span><br><span class="line">        let value=this.getTextVal(vm,expr);</span><br><span class="line">        expr.replace(/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g,(...arguments)=&gt;&#123;</span><br><span class="line">            new Watcher(vm,arguments[1],(newValue)=&gt;&#123;</span><br><span class="line">            	//如果数据变化了，文本节点需要重新获取依赖的属性更新文本中的内容</span><br><span class="line">                updateFn&amp;&amp;updateFn(node,this.getTextVal(vm,expr));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,value);</span><br><span class="line">    &#125;,</span><br><span class="line">    setVal(vm,expr,value)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next,currentIndex)=&gt;&#123;</span><br><span class="line">            if(currentIndex===expr.length-1)&#123;</span><br><span class="line">                return prev[next]=value;</span><br><span class="line">            &#125;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data)</span><br><span class="line">    &#125;,</span><br><span class="line">    model(node,vm,expr)&#123; //输入框处理</span><br><span class="line">        let updateFn=this.updater[&apos;modelUpdater&apos;];</span><br><span class="line">        //这里应该加一个监控，数据变化了应该调用这个watch的callback</span><br><span class="line">        new Watcher(vm,expr,(newValue)=&gt;&#123;</span><br><span class="line">        	//当值变化后会调用cb 将新的值传递过来</span><br><span class="line">             updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">        &#125;)</span><br><span class="line">        node.addEventListener(&apos;input&apos;,e=&gt;&#123;</span><br><span class="line">            let newValue =e.target.value;</span><br><span class="line">            this.setVal(vm,expr,newValue)</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn&amp;&amp;updateFn(node,this.getVal(vm.expr));</span><br><span class="line">    &#125;,</span><br><span class="line">    updater:&#123;</span><br><span class="line">        textUpdater(node,value)&#123; //文本更新</span><br><span class="line">            node.textContent=value;</span><br><span class="line">        &#125;,</span><br><span class="line">        modelUpdater(node,value)&#123; //输入框更新</span><br><span class="line">            node.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">observer.js  </span><br><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data)&#123;</span><br><span class="line">        //要对这个data数据的所有属性改成set和get的形式</span><br><span class="line">        if(!data || typeof data !== &apos;object&apos;)&#123;//数据不存在或者数据不是对象，就不用劫持了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //要将数据一一劫持，先获取到data的key和value</span><br><span class="line">        Object.keys(data).forEach(key=&gt;&#123;</span><br><span class="line">            //劫持</span><br><span class="line">            this.defineReactive(data,key,data[key])；</span><br><span class="line">            this.observer(data[key])//深度劫持</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    //定义响应式</span><br><span class="line">    defineReactive(obj,key,value)&#123;</span><br><span class="line">        let that=this;</span><br><span class="line">        let dep=new Dep();//每个变化的数据，都会对应一个数组，这个数组存放所有更新的操作。</span><br><span class="line">        Object.defineProperty(obj,key,&#123;</span><br><span class="line">            enumerable:true,</span><br><span class="line">            configurable:true,</span><br><span class="line">            get()&#123;</span><br><span class="line">            	//获取属性值的时候可以todo.....</span><br><span class="line">            	Dep.target &amp;&amp;dep.addSub(Dep.target);</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">            set(newValue)&#123; </span><br><span class="line">            	//设置属性值的时候可以todo.....(做一些想做的事)</span><br><span class="line">                if(newValue != value)&#123;</span><br><span class="line">                	that.observer(newValue);//如果新值是对象还得继续劫持，这里面的this不是实例。</span><br><span class="line">                    value = newValue;</span><br><span class="line">                    dep.notify();//通知所有人，数据更新了。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dep&#123;</span><br><span class="line">    //发布订阅</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs=[];</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(watcher)&#123;</span><br><span class="line">        this.subs.push(watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(watcher=&gt;watcher.update());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">watcher.js</span><br><span class="line">//观察者的目的就是给需要变化的那个元素增加一个观察者，当数据变化后执行对应的方法。</span><br><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(vm,expr,cb)&#123;</span><br><span class="line">        this.vm=vm;</span><br><span class="line">        this.expr=expr;</span><br><span class="line">        this.cb=cb;</span><br><span class="line">        //先获取一下老值</span><br><span class="line">        this.value=this.get();</span><br><span class="line">    &#125;</span><br><span class="line">    getVal(vm,expr)&#123;</span><br><span class="line">        expr=expr.split(&apos;.&apos;);</span><br><span class="line">        return expr.reduce((prev,next)=&gt;&#123;</span><br><span class="line">            return prev[next];</span><br><span class="line">        &#125;,vm.$data);</span><br><span class="line">    &#125;</span><br><span class="line">    get()&#123;</span><br><span class="line">    	Dep.target=this;</span><br><span class="line">        let value=this.getVal(this.vm,this.expr);</span><br><span class="line">        Dep.target=null;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    //对外暴露的方法</span><br><span class="line">    update()&#123;</span><br><span class="line">        let newValue=this.getVal(this.vm,this.expr);</span><br><span class="line">        let oldValue=this.value;</span><br><span class="line">        if(newValue != oldValue)&#123;</span><br><span class="line">            this.cb(newValue);//对应watch的callback;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//用新值和老值进行对比，如果发生变化，就调用更新方法</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue、mvvm/">vue、mvvm</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jsjicheng" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/jsjicheng/" class="article-date">
      <time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/jsjicheng/">js中的继承方式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getX = function ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function B()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</span><br><span class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</span><br></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">    this.x = 100; //d.x = 100</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function D()&#123;</span><br><span class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function E()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">E.prototype.getX = function ()&#123;&#125;</span><br><span class="line">function F()&#123;</span><br><span class="line">    var e = new E(); //e.x = 100;</span><br><span class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</span><br><span class="line">        //attr = x</span><br><span class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</span><br><span class="line">            this[attr] = e[attr];</span><br><span class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</span><br><span class="line">        &#125;</span><br><span class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function G()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">G.prototype.getX = function()&#123;&#125;;</span><br><span class="line">function H()&#123;</span><br><span class="line">    G.call(this);</span><br><span class="line">&#125;</span><br><span class="line">H.prototype = new G();</span><br><span class="line">H.prototype.constructor = H;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function K()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">k.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function M()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</span><br></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.name = &quot;ywx&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">//寄生组合式继承实现方式如下：</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">var child=new Child();</span><br><span class="line">console.log(child.eat());//只有找到父类原型上的方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js继承、原型链/">js继承、原型链</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-windows" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/28/nginx-windows/" class="article-date">
      <time datetime="2017-04-28T08:50:18.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/nginx-windows/">Windows下Nginx的启动、停止等命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。</p>
<h4 id="1、启动："><a href="#1、启动：" class="headerlink" title="1、启动："></a>1、启动：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;start nginx</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe</div></pre></td></tr></table></figure>
<p>注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。</p>
<h4 id="2、停止："><a href="#2、停止：" class="headerlink" title="2、停止："></a>2、停止：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s stop</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s quit</div></pre></td></tr></table></figure>
<p>注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。</p>
<h4 id="3、重新载入Nginx："><a href="#3、重新载入Nginx：" class="headerlink" title="3、重新载入Nginx："></a>3、重新载入Nginx：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reload</div></pre></td></tr></table></figure>
<p>当配置信息修改，需要重新载入这些配置时使用此命令。不重新启动不会生效。</p>
<h4 id="4、重新打开日志文件："><a href="#4、重新打开日志文件：" class="headerlink" title="4、重新打开日志文件："></a>4、重新打开日志文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reopen</div></pre></td></tr></table></figure>
<h4 id="5、查看Nginx版本："><a href="#5、查看Nginx版本：" class="headerlink" title="5、查看Nginx版本："></a>5、查看Nginx版本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx -v</div></pre></td></tr></table></figure>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>注：以上C:\server\nginx-1.0.2需要改成自已nginx的安装目录。每次写路径太麻烦，可以把C:\server\nginx-1.0.2配置成环境变量，这样就不用每次都写路径了，在任意目录下打开git或者cmd直接执行命令，系统会自己在环境变量path中查找。在此做下特殊说明：window下就算nginx配置好了环境变量，有些命令（比如：nginx -s stop）也无法用，会报错。</p>
<p>一、在cmd中，逐步进入到nginx的安装目录，在此目录下执行那些命令都可以。一步步进安装目录如果麻烦，可以执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start /D E:\nginx\nginx-1.6.2 nginx -s start</div><div class="line">Windows下的话可以用start命令，/D参数指定起始目录，这样在执行nginx命令前重新设定了指定的目录。</div></pre></td></tr></table></figure></p>
<p>此时会cmd会自动把路径跳转到nginx的安装目录了，此时也可以执行命令了。</p>
<p>二、也可以在安装目录下打开git,输入./nginx按回车，即启动了nginx,再按ctrl+c关闭nginx.</p>
<p>三、可以双击nginx.exe启动nginx,当修改了nginx.conf配置文件时，此时要重启，先在任务管理器中结束nginx的进程（打开任务管理器，输入英文字母n，可以快速定位到以n开头的应用，方便查找了），然后在双击运行nginx。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-configuration-start" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/nginx-configuration-start/" class="article-date">
      <time datetime="2017-04-26T08:34:27.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/nginx-configuration-start/">Nginx 配置简述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>不论是本地开发，还是远程到 Server 开发，还是给提供 demo 给人看效果，我们时常需要对 Nginx 做配置，Nginx 的配置项相当多，如果考虑性能配置起来会比较麻烦。不过，我们往往只是需要一个静态 Server，或者一个反向代理 Server，这对 Nginx 来说小菜一碟。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Nginx 的安装就不解释了，方便起见，也可以在各平台可以直接执行对应安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># CentOS</div><div class="line">yum install nginx;</div><div class="line"># Ubuntu</div><div class="line">sudo apt-get install nginx;</div><div class="line"># Mac</div><div class="line">brew install nginx;</div></pre></td></tr></table></figure></p>
<p>常用的设置一般可以在 /etc/nginx/nginx.conf 中配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">下面是linux下的启动参数（windows的启动命令和其不一样）：</div><div class="line"># 启动</div><div class="line">nginx -s start;</div><div class="line"># 重新启动，热启动，修改配置重启不影响线上</div><div class="line">nginx -s reload;</div><div class="line"># 关闭</div><div class="line">nginx -s stop;</div><div class="line"># 修改配置后，可以通过下面的命令测试是否有语法错误</div><div class="line">nginx -t;</div></pre></td></tr></table></figure></p>
<p>-s，signal，意思就是向 nginx 发送 start|reload|stop 命令，还是很好理解的。先看一个最简单的 nginx.conf 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 需要保留这一个段落，可以为空</div><div class="line">    # 为注释的意思</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        location / &#123;</div><div class="line">            root /home/webywx/test/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动后，访问 <a href="http://127.0.0.1:8888" target="_blank" rel="external">http://127.0.0.1:8888</a> ，如果 /home/webywx/test/ 下有 index.html 文件就会展示 index.html 的内容，否则返回 404。</p>
<h4 id="Nginx-配置一个-Web-服务器"><a href="#Nginx-配置一个-Web-服务器" class="headerlink" title="Nginx 配置一个 Web 服务器"></a>Nginx 配置一个 Web 服务器</h4><p>以下是对配置 Web 服务器的参数做简单说明，包括如何配置端口、域名，如何处理请求，如何响应请求。</p>
<p>1、 虚拟主机和请求的分发<br>域名和端口的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">listen 127.0.0.1:8000;</div><div class="line">listen *:8000;</div><div class="line">listen localhost:8000;</div><div class="line"># IPV6</div><div class="line">listen [::]:8000;</div><div class="line"># other params</div><div class="line">listen 443 default_serer ssl;</div><div class="line">listen 127.0.0.1 default_server accept_filter=dataready backlog=1024</div></pre></td></tr></table></figure></p>
<p>主机名配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server_name www.webywx.com webywx.com</div><div class="line">server_name *.webywx.com</div><div class="line">server_name ~^\.web\.com$</div></pre></td></tr></table></figure></p>
<p>URI 匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location = / &#123;</div><div class="line">    # 完全匹配  =</div><div class="line">    # 大小写敏感 ~</div><div class="line">    # 忽略大小写 ~*</div><div class="line">&#125;</div><div class="line">location ^~ /images/ &#123;</div><div class="line">    # 前半部分匹配 ^~</div><div class="line">    # 可以使用正则，如：</div><div class="line">    # location ~* \.(gif|jpg|png)$ &#123; &#125;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 如果以上都未匹配，会进入这里</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 文件路径的定义<br>根目录设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root /home/webywx/test/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>别名设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    alias /home/webywx/www/blog/;</div><div class="line">&#125;</div><div class="line">location ~ ^/blog/(\d+)/([\w-]+)$ &#123;</div><div class="line">    alias /home/webywx/www/blog/$1-$2.md;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首页设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index /html/index.html /php/index.php;</div></pre></td></tr></table></figure></p>
<p>重定向页面设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">error_page    404         /404.html;</div><div class="line">error_page    502  503    /50x.html;</div><div class="line">error_page    404  =200   /1x1.gif;</div><div class="line">location / &#123;</div><div class="line">    error_page  404 @fallback;</div><div class="line">&#125;</div><div class="line">location @fallback &#123;</div><div class="line">    # 将请求反向代理到上游服务器处理</div><div class="line">    proxy_pass http://localhost:9000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>try_files 设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try_files $uri $uri.html $uri/index.html @other;</div><div class="line">location @other &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，失败了就会转到上游处理</div><div class="line">    proxy_pass  http://localhost:9000;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，没找到直接返回 502</div><div class="line">    try_files $uri $uri.html =502;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx-配置反向代理服务器"><a href="#Nginx-配置反向代理服务器" class="headerlink" title="Nginx 配置反向代理服务器"></a>Nginx 配置反向代理服务器</h4><p>反向代理（reserve proxy）方式是指用代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络中的上游服务器，并将上游服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外的表现就是一个 Web 服务器。</p>
<p>Nginx 具备超强的高并发高负载能力，一般会作为前端的服务器直接向客户端提供静态文件服务；而业务一般还包含一些业务逻辑需要 Apache、Tomcat 等服务器来处理，故通常 Nginx 对外表现即为静态 Web 服务器也是反向代理服务器。</p>
<p>缺点是增加了一次请求的处理时间，优点是降低了上游服务器的负载，尽量将压力放在 Nginx 服务器上。</p>
<p>1、负载均衡配置<br>upstream，定义一个上游服务器集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    # ip_hash;</div><div class="line">    server s1.webywx.com;</div><div class="line">    server s2.webywx.com;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://backend;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、反向代理<br>proxy_pass 将请求转发到有处理能力的端上，默认不会转发请求中的 Host 头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    prox_pass http://localhost:9000;</div><div class="line">    ### 下面都是次要关注项</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_method POST;</div><div class="line">    # 指定不转发的头部字段</div><div class="line">    proxy_hide_header Cache-Control;</div><div class="line">    proxy_hide_header Other-Header;</div><div class="line">    # 指定转发的头部字段</div><div class="line">    proxy_pass_header Server-IP;</div><div class="line">    proxy_pass_header Server-Name;</div><div class="line">    # 是否转发包体</div><div class="line">    proxy_pass_request_body on | off;</div><div class="line">    # 是否转发头部</div><div class="line">    proxy_pass_request_headers on | off;</div><div class="line">    # 显形/隐形 URI，上游发生重定向时，Nginx 是否同步更改 uri</div><div class="line">    proxy_redirect on | off;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="一个简单的例子，Node-js"><a href="#一个简单的例子，Node-js" class="headerlink" title="一个简单的例子，Node.js"></a>一个简单的例子，Node.js</h4><p>一个十分常见的需求：处理请求，如果是静态文件，Nginx 直接返回，否则交给 Node 服务器处理。首先创建了一个 Node 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line">http.createServer((req, res) =&gt; &#123;</div><div class="line">    res.end(&apos;hello world&apos;);</div><div class="line">&#125;).listen(9000);</div></pre></td></tr></table></figure></p>
<p>任何请求过来都返回 hello world，简版的 Nginx 配置如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 这里可不写东西</div><div class="line">    use epoll;</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">        try_files $uri $uri/index.html;</div><div class="line">        location ~* ^/(js|css|image|font)/$ &#123;</div><div class="line">            # 静态资源都在 static 文件夹下</div><div class="line">            root /home/webywx/www/static/;</div><div class="line">        &#125;</div><div class="line">        location /app &#123;</div><div class="line">            # Node.js 在 9000 开了一个监听端口</div><div class="line">            proxy_pass http://127.0.0.1:9000;</div><div class="line">        &#125;</div><div class="line">        # 上面处理出错或者未找到的，返回对应状态码文件</div><div class="line">        error_page    404            /404.html;</div><div class="line">        error_page    502  503  504  /50x.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先 try_files，尝试直接匹配文件；没找到就匹配静态资源；还没找到就交给 Node 处理；否则就返回 4xx/5xx 的状态码。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>边学边动手尝试，利用 nginx -t 测试语法，遇到问题就 Google 搜索下，上手应该还是很快的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-interview-css" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/interview-css/" class="article-date">
      <time datetime="2017-04-26T07:10:31.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/interview-css/">前端笔试面试中的常用到的CSS知识点总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成积累的习惯。</p>
<h4 id="1、CSS选择器的优先级"><a href="#1、CSS选择器的优先级" class="headerlink" title="1、CSS选择器的优先级"></a>1、CSS选择器的优先级</h4><p>!important &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器<br>多个类选择器叠加（256）之后的优先级大于一个id选择器<br>!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。<br>CSS选择器的种类：<br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p>
<h4 id="2、CSS优先级权重计算法"><a href="#2、CSS优先级权重计算法" class="headerlink" title="2、CSS优先级权重计算法"></a>2、CSS优先级权重计算法</h4><p>CSS优先级的计算规则如下：<br>元素标签中定义的样式（Style属性）,加1,0,0,0<br>每个ID选择符(如 #id),加0,1,0,0<br>每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0<br>每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1<br>然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值<br>然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。<br>前一等级相等才往后比，依次类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">例如果样式中有两个id选择符，则为0,2,0,0;</div><div class="line">#div1 #div2&#123;</div><div class="line">color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"><a href="#3、超链接访问过后hover样式就不出现的问题是什么？如何解决？" class="headerlink" title="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"></a>3、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h4><p>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）,为了便于记忆，可以记love hate;</p>
<h4 id="4、什么是Css-Hack？ie6-7-8的hack分别是什么？"><a href="#4、什么是Css-Hack？ie6-7-8的hack分别是什么？" class="headerlink" title="4、什么是Css Hack？ie6,7,8的hack分别是什么？"></a>4、什么是Css Hack？ie6,7,8的hack分别是什么？</h4><p>针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#test   &#123;   </div><div class="line">        width:300px;   </div><div class="line">        height:300px;   </div><div class="line">        background-color:blue;      /*firefox*/</div><div class="line">        background-color:red\9;      /*all ie*/</div><div class="line">        background-color:yellow\0;    /*ie8*/</div><div class="line">        +background-color:pink;        /*ie7*/</div><div class="line">        _background-color:orange;       /*ie6*/    &#125;  </div><div class="line">        :root #test &#123; background-color:purple\9; &#125;  /*ie9*/</div><div class="line">    @media all and (min-width:0px)&#123; </div><div class="line">          #test &#123;background-color:black\0;&#125; </div><div class="line">     &#125;  /*opera*/</div><div class="line">    @media screen and (-webkit-min-device-pixel-ratio:0)&#123; </div><div class="line">#test &#123;background-color:gray;&#125; </div><div class="line">&#125;       /*chrome and safari*/</div></pre></td></tr></table></figure></p>
<h4 id="5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？"><a href="#5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？" class="headerlink" title="5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？"></a>5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h4><p>不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。<br>你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p>
<h4 id="6、display-none与visibility-hidden的区别是什么？"><a href="#6、display-none与visibility-hidden的区别是什么？" class="headerlink" title="6、display:none与visibility:hidden的区别是什么？"></a>6、display:none与visibility:hidden的区别是什么？</h4><p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br>即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>
<h4 id="7、CSS盒子模型"><a href="#7、CSS盒子模型" class="headerlink" title="7、CSS盒子模型"></a>7、CSS盒子模型</h4><p>Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。</p>
<p><div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/box-model.png-public" alt=""><br></div><br>如上图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分，这就是标准的盒模型（它的宽高就是指content区）。但盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box），IE盒模型又称怪异盒模型（它的宽高包含border、内边距和content）。</p>
<h4 id="8、相对定位relative、浮动float以及绝对定位absolute的区别？"><a href="#8、相对定位relative、浮动float以及绝对定位absolute的区别？" class="headerlink" title="8、相对定位relative、浮动float以及绝对定位absolute的区别？"></a>8、相对定位relative、浮动float以及绝对定位absolute的区别？</h4><p>1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。<br>2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。<br>3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。</p>
<h4 id="9、清除浮动的用法？"><a href="#9、清除浮动的用法？" class="headerlink" title="9、清除浮动的用法？"></a>9、清除浮动的用法？</h4><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br>使用方法：<br>1、在浮动元素后使用一个空元素如<br>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。<br>2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动<br>3、什么都不做，给浮动元素后面的元素添加clear属性。<br>4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//一种常见利用伪类清除浮动的代码</div><div class="line"> .clearfix:after &#123;</div><div class="line">    content:&quot;.&quot;;       //这里利用到了content属性</div><div class="line">    display:block; </div><div class="line">    height:0;</div><div class="line">    visibility:hidden; </div><div class="line">    clear:both; </div><div class="line">&#125;</div><div class="line">.clearfix &#123; </div><div class="line">    *zoom:1; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"><a href="#10、BOX模型的margin在IE比在其他浏览器大2px的解决办法" class="headerlink" title="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"></a>10、BOX模型的margin在IE比在其他浏览器大2px的解决办法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div&#123;margin:30px!important;margin:28px;&#125;</div></pre></td></tr></table></figure>
<p>注意这两个margin的顺序一定不能写反，!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：<br>div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;<br>也可以用hack写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div &#123; _margin:28px;margin:28px\9;margin:30px;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="11、IE-3像素Bug的产生原因及解决办法"><a href="#11、IE-3像素Bug的产生原因及解决办法" class="headerlink" title="11、IE 3像素Bug的产生原因及解决办法"></a>11、IE 3像素Bug的产生原因及解决办法</h4><p>当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。<br>解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。</p>
<h4 id="12、IE6-双边距Bug的产生原因及解决办法"><a href="#12、IE6-双边距Bug的产生原因及解决办法" class="headerlink" title="12、IE6 双边距Bug的产生原因及解决办法"></a>12、IE6 双边距Bug的产生原因及解决办法</h4><p>当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。<br>解决办法：添加_display:inline</p>
<h4 id="13、文本溢出省略的处理方法"><a href="#13、文本溢出省略的处理方法" class="headerlink" title="13、文本溢出省略的处理方法"></a>13、文本溢出省略的处理方法</h4><p>1)单行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.inline&#123;</div><div class="line">  overflow:hidden;</div><div class="line">         white-space:nowrap;</div><div class="line">         text-overflow:ellipsis; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)多行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.foo&#123;</div><div class="line">  display:-webkit-box!important;</div><div class="line">  overflow:hidden;</div><div class="line">  text-overflow:ellipsis;</div><div class="line">  work-break:break-all;</div><div class="line">  -webkit-box-orient:vertical; /*方向*/</div><div class="line">  -webkit-line-clamp:4; /*显示多少行文本*/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。</p>
<h4 id="14、CSS实现垂直水平居中"><a href="#14、CSS实现垂直水平居中" class="headerlink" title="14、CSS实现垂直水平居中"></a>14、CSS实现垂直水平居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">.parent &#123;</div><div class="line">          width:800px;</div><div class="line">          height:500px;</div><div class="line">          border:2px solid #000;</div><div class="line">          position:relative;</div><div class="line">&#125;</div><div class="line"> .child &#123;</div><div class="line">        width:200px;</div><div class="line">        height:200px;</div><div class="line">        margin: auto;  </div><div class="line">        position: absolute;  </div><div class="line">        top: 0; left: 0; bottom: 0; right: 0; </div><div class="line">        background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法2：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:table-cell;</div><div class="line">    vertical-align:middle;</div><div class="line">    text-align: center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    display:inline-block;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">方法3：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:flex;</div><div class="line">    justify-content:center;</div><div class="line">    align-items:center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">方法4：</div><div class="line">.parent &#123;</div><div class="line">        width:800px;</div><div class="line">        height:500px;</div><div class="line">        border:2px solid #000;</div><div class="line">        position:relative;</div><div class="line">    &#125;</div><div class="line">.child &#123;</div><div class="line">    width:300px;</div><div class="line">    height:200px;</div><div class="line">    margin:auto;</div><div class="line">    position:absolute;</div><div class="line">//设定水平和垂直偏移父元素的50%，</div><div class="line">//再根据实际长度将子元素上左挪回一半大小</div><div class="line">    left:50%;</div><div class="line">    top:50%;</div><div class="line">    margin-left: -150px;</div><div class="line">    margin-top:-100px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="15、BFC"><a href="#15、BFC" class="headerlink" title="15、BFC"></a>15、BFC</h4><p>块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。<br>BFC的创建方法：<br>根元素或其它包含它的元素；<br>浮动 (元素的float不为none)；<br>绝对定位元素 (元素的position为absolute或fixed)；<br>行内块inline-blocks(元素的 display: inline-block)；<br>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；<br>overflow的值不为visible的元素；<br>弹性盒 flex boxes (元素的display: flex或inline-flex)；</p>
<h4 id="16、响应式图片的CSS"><a href="#16、响应式图片的CSS" class="headerlink" title="16、响应式图片的CSS"></a>16、响应式图片的CSS</h4><p>所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">width:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">max-width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="17、CSS响应式网格系统原理"><a href="#17、CSS响应式网格系统原理" class="headerlink" title="17、CSS响应式网格系统原理"></a>17、CSS响应式网格系统原理</h4><p>总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    box-sizing: border-box;</div><div class="line">&#125;</div><div class="line">[class*=&quot;col-&quot;] &#123;</div><div class="line">    float: left;</div><div class="line">    padding: 15px;</div><div class="line">    border: 1px solid red;</div><div class="line">&#125;</div><div class="line">.col-1 &#123;width: 8.33%;&#125;</div><div class="line">.col-2 &#123;width: 16.66%;&#125;</div><div class="line">.col-3 &#123;width: 25%;&#125;</div><div class="line">.col-4 &#123;width: 33.33%;&#125;</div><div class="line">.col-5 &#123;width: 41.66%;&#125;</div><div class="line">.col-6 &#123;width: 50%;&#125;</div><div class="line">.col-7 &#123;width: 58.33%;&#125;</div><div class="line">.col-8 &#123;width: 66.66%;&#125;</div><div class="line">.col-9 &#123;width: 75%;&#125;</div><div class="line">.col-10 &#123;width: 83.33%;&#125;</div><div class="line">.col-11 &#123;width: 91.66%;&#125;</div><div class="line">.col-12 &#123;width: 100%;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="18、用LESS循环实现栅格类"><a href="#18、用LESS循环实现栅格类" class="headerlink" title="18、用LESS循环实现栅格类"></a>18、用LESS循环实现栅格类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.generate-columns(12);</div><div class="line">.generate-columns(@n; @i: 1) when (@i =&lt; @n) &#123;</div><div class="line">  .column-@&#123;i&#125; &#123;</div><div class="line">    width: (@i * 100% / @n);</div><div class="line">  &#125;</div><div class="line">.generate-columns(@n, (@i + 1));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="19、使用perspective属性和transform：perspective-函数的区别"><a href="#19、使用perspective属性和transform：perspective-函数的区别" class="headerlink" title="19、使用perspective属性和transform：perspective()函数的区别"></a>19、使用perspective属性和transform：perspective()函数的区别</h4><p>以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。<br>perspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)<br>transform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br>backface-visibility：hidden|visibility设置背后元素是否可见</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-前端开发/">css 前端开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-flexintroduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/20/flexintroduction/" class="article-date">
      <time datetime="2017-02-20T03:09:43.000Z" itemprop="datePublished">2017-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/20/flexintroduction/">学习flex布局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<h4 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行内元素也可以使用Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Webkit内核的浏览器，必须加上-webkit前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: -webkit-flex; /* Safari */</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h4><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h4 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h4><p>以下6个属性设置在容器上。<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>
<p>更多学习内容参考以下链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex-css3/">flex css3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-rengemianju" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/19/rengemianju/" class="article-date">
      <time datetime="2017-02-19T09:32:10.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/rengemianju/">人格面具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>
<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>
<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>
<h4 id="人格面具"><a href="#人格面具" class="headerlink" title="人格面具"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>
<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>
<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>
<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>
<h4 id="你看到的未必就是真实，你以为的也不过就是你以为而已。"><a href="#你看到的未必就是真实，你以为的也不过就是你以为而已。" class="headerlink" title="你看到的未必就是真实，你以为的也不过就是你以为而已。"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>
<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>
<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>
<h4 id="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"><a href="#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。" class="headerlink" title="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>
<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>
<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>
<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>
<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>
<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-lovestart" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/14/lovestart/" class="article-date">
      <time datetime="2017-02-14T09:15:48.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/lovestart/">爱的开始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <iframe style="margin:0 auto; display:block;" frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66"></iframe>

<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>
<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>
<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>
<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>
<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>
<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>
<h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>
<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-web-workers" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/10/web-workers/" class="article-date">
      <time datetime="2017-02-10T03:53:05.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/web-workers/">程序性能之HTML5 Web Workers</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="什么是-Web-Worker？"><a href="#什么是-Web-Worker？" class="headerlink" title="什么是 Web Worker？"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>
<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>也可以发送 “message” 事件给这个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.postMessage( &quot;something cool to say&quot; );</div></pre></td></tr></table></figure></p>
<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// &quot;mycoolworker.js&quot;</div><div class="line">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div><div class="line">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</div></pre></td></tr></table></figure></p>
<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>
<h4 id="Web-Worker-通常应用于哪些方面呢？"><a href="#Web-Worker-通常应用于哪些方面呢？" class="headerlink" title="Web Worker 通常应用于哪些方面呢？"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if(typeof(Worker)!==&quot;undefined&quot;)</div><div class="line">  &#123;</div><div class="line">  // Yes! Web worker support!</div><div class="line">  // Some code.....</div><div class="line">  &#125;</div><div class="line">else</div><div class="line">  &#123;</div><div class="line">  // Sorry! No Web Worker support..</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Worker环境"><a href="#Worker环境" class="headerlink" title="Worker环境"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 在Worker内部</div><div class="line">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>
<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href="https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）" target="_blank" rel="external">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>
<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href="http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，" target="_blank" rel="external">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>
<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href="http://developer.mozilla.org/enUS/docs/Web/API/Transferable" target="_blank" rel="external">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 比如foo是一个Uint8Array</div><div class="line">postMessage( foo.buffer, [ foo.buffer ] );</div></pre></td></tr></table></figure></p>
<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>
<h4 id="共享-Worker"><a href="#共享-Worker" class="headerlink" title="共享 Worker"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class="line">// ..</div><div class="line">w1.port.postMessage( &quot;something cool&quot; );</div></pre></td></tr></table></figure></p>
<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.port.start();</div></pre></td></tr></table></figure></p>
<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在共享Worker内部</div><div class="line">addEventListener( &quot;connect&quot;, function(evt)&#123;</div><div class="line">// 这个连接分配的端口</div><div class="line">var port = evt.ports[0];</div><div class="line">port.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// ..</div><div class="line">port.postMessage( .. );</div><div class="line">// ..</div><div class="line">&#125; );</div><div class="line">// 初始化端口连接</div><div class="line">port.start();</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件（ 即程序） ， 使用异步事件在线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程中，以提高主 UI 线程的响应性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h5-webworkers/">h5 webworkers</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Wenxi Yan
            </div>
            <div class="footer-right">
                <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >用户到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>