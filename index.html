<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闫文喜的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫文喜的个人博客">
<meta property="og:url" content="http://yanwenxi.github.io/index.html">
<meta property="og:site_name" content="闫文喜的个人博客">
<meta property="og:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
<meta property="og:locale" content="中文">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫文喜的个人博客">
<meta name="twitter:description" content="闫文喜，闫文喜的个人博客，web前端博客，前端博客">
  
    <link rel="alternative" href="/atom.xml" title="闫文喜的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Wenxi Yan</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">我的小窝</a></li>
                        
                            <li><a href="/archives">文章列表</a></li>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/about">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                            
                                <a class="fl QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                            
                                <a class="fl wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Benchmark-jsPerf/" style="font-size: 10px;">Benchmark jsPerf</a> <a href="/tags/ES6、promise/" style="font-size: 10px;">ES6、promise</a> <a href="/tags/H5-移动端优化/" style="font-size: 10px;">H5 移动端优化</a> <a href="/tags/H5、bug/" style="font-size: 10px;">H5、bug</a> <a href="/tags/JS设计模式-设计模式/" style="font-size: 10px;">JS设计模式 设计模式</a> <a href="/tags/Jenkins-CI/" style="font-size: 10px;">Jenkins CI</a> <a href="/tags/Lodash/" style="font-size: 10px;">Lodash</a> <a href="/tags/angular/" style="font-size: 10px;">angular</a> <a href="/tags/angular-http-q-promise/" style="font-size: 10px;">angular $http $q promise</a> <a href="/tags/angular-q-promise/" style="font-size: 10px;">angular $q promise</a> <a href="/tags/angular-decorator/" style="font-size: 10px;">angular decorator</a> <a href="/tags/angular-filter/" style="font-size: 10px;">angular filter</a> <a href="/tags/angular-服务/" style="font-size: 10px;">angular 服务</a> <a href="/tags/angularjs/" style="font-size: 10px;">angularjs</a> <a href="/tags/angular、-http/" style="font-size: 10px;">angular、$http</a> <a href="/tags/angular、Karma/" style="font-size: 10px;">angular、Karma</a> <a href="/tags/angular、directive/" style="font-size: 10px;">angular、directive</a> <a href="/tags/angular、html5/" style="font-size: 10px;">angular、html5</a> <a href="/tags/angular、module、controller/" style="font-size: 10px;">angular、module、controller</a> <a href="/tags/angular、promise、-q、deferred/" style="font-size: 10px;">angular、promise、$q、deferred</a> <a href="/tags/angular、router/" style="font-size: 10px;">angular、router</a> <a href="/tags/angular、ui-router/" style="font-size: 10px;">angular、ui-router</a> <a href="/tags/angular、表达式、filter/" style="font-size: 10px;">angular、表达式、filter</a> <a href="/tags/app-跨平台/" style="font-size: 10px;">app,跨平台</a> <a href="/tags/aso/" style="font-size: 10px;">aso</a> <a href="/tags/blockchain/" style="font-size: 10px;">blockchain</a> <a href="/tags/css-前端开发/" style="font-size: 10px;">css 前端开发</a> <a href="/tags/debugger/" style="font-size: 10px;">debugger</a> <a href="/tags/es5-js/" style="font-size: 10px;">es5 js</a> <a href="/tags/fit/" style="font-size: 10px;">fit</a> <a href="/tags/flex-css3/" style="font-size: 10px;">flex css3</a> <a href="/tags/git-github/" style="font-size: 10px;">git github</a> <a href="/tags/h5-webworkers/" style="font-size: 10px;">h5 webworkers</a> <a href="/tags/i18n/" style="font-size: 10px;">i18n</a> <a href="/tags/iframe/" style="font-size: 10px;">iframe</a> <a href="/tags/javascript、object-oriented、继承/" style="font-size: 10px;">javascript、object-oriented、继承</a> <a href="/tags/jquery/" style="font-size: 10px;">jquery</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-Array/" style="font-size: 10px;">js Array</a> <a href="/tags/js-Higher-order-function/" style="font-size: 10px;">js Higher-order-function</a> <a href="/tags/js-closure/" style="font-size: 10px;">js closure</a> <a href="/tags/js-lodash/" style="font-size: 10px;">js lodash</a> <a href="/tags/js-object/" style="font-size: 10px;">js object</a> <a href="/tags/js-scope/" style="font-size: 10px;">js scope</a> <a href="/tags/js-sea-js-模块化/" style="font-size: 10px;">js sea.js 模块化</a> <a href="/tags/js-this/" style="font-size: 10px;">js this</a> <a href="/tags/js-性能调试-Benchmark-jsPerf/" style="font-size: 10px;">js 性能调试 Benchmark jsPerf</a> <a href="/tags/js-柯里化/" style="font-size: 10px;">js 柯里化</a> <a href="/tags/js-纯函数/" style="font-size: 10px;">js 纯函数</a> <a href="/tags/js、变态题/" style="font-size: 10px;">js、变态题</a> <a href="/tags/js、设计模式/" style="font-size: 10px;">js、设计模式</a> <a href="/tags/js、跨域、document-domain/" style="font-size: 10px;">js、跨域、document.domain</a> <a href="/tags/js模块化、AMD、CMD、CommonJs/" style="font-size: 10px;">js模块化、AMD、CMD、CommonJs</a> <a href="/tags/js继承/" style="font-size: 10px;">js继承</a> <a href="/tags/life、意念/" style="font-size: 10px;">life、意念</a> <a href="/tags/lodash-chain/" style="font-size: 10px;">lodash chain</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongoDB-数据库/" style="font-size: 10px;">mongoDB 数据库</a> <a href="/tags/mvp/" style="font-size: 10px;">mvp</a> <a href="/tags/nginx/" style="font-size: 12.5px;">nginx</a> <a href="/tags/node/" style="font-size: 12.5px;">node</a> <a href="/tags/node-debug/" style="font-size: 10px;">node debug</a> <a href="/tags/node-wechat/" style="font-size: 20px;">node wechat</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/rap/" style="font-size: 17.5px;">rap</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/react-ant-design/" style="font-size: 10px;">react ant-design</a> <a href="/tags/seo/" style="font-size: 20px;">seo</a> <a href="/tags/seo-新闻源/" style="font-size: 10px;">seo 新闻源</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/web-交互/" style="font-size: 10px;">web 交互</a> <a href="/tags/web、前端/" style="font-size: 10px;">web、前端</a> <a href="/tags/web、性能优化/" style="font-size: 10px;">web、性能优化</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a> <a href="/tags/wechat-webstorm/" style="font-size: 10px;">wechat webstorm</a> <a href="/tags/win10、linux/" style="font-size: 10px;">win10、linux</a> <a href="/tags/window-history-html5/" style="font-size: 10px;">window.history html5</a> <a href="/tags/wxapp/" style="font-size: 15px;">wxapp</a> <a href="/tags/yarn-npm/" style="font-size: 10px;">yarn npm</a> <a href="/tags/人生/" style="font-size: 10px;">人生</a> <a href="/tags/前后端分享/" style="font-size: 10px;">前后端分享</a> <a href="/tags/前端工程-构建工具-前端开发/" style="font-size: 10px;">前端工程 构建工具 前端开发</a> <a href="/tags/前端脚手架/" style="font-size: 10px;">前端脚手架</a> <a href="/tags/建站-seo/" style="font-size: 10px;">建站 seo</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/我是点位的以后改/" style="font-size: 10px;">我是点位的以后改</a> <a href="/tags/生活/" style="font-size: 20px;">生活</a> <a href="/tags/移动端、fixed/" style="font-size: 10px;">移动端、fixed</a> <a href="/tags/解构赋值-es6/" style="font-size: 10px;">解构赋值 es6</a> <a href="/tags/跨域、postMessage、html5/" style="font-size: 10px;">跨域、postMessage、html5</a> <a href="/tags/路由-html5/" style="font-size: 10px;">路由 html5</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.webywx.com">前端小站</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://ywxi.github.io/">web博客</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">运动健身、网络营销、web前端、喜欢接触新鲜事物、迎接新的挑战</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Wenxi Yan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Wenxi Yan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">我的小窝</a></li>
                
                    <li><a href="/archives">文章列表</a></li>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/about">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/yanwenxi" title="github">github</a>
                    
                        <a class="QQ" target="_blank" href="http://www.webywx.com" title="QQ">QQ</a>
                    
                        <a class="wechat" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=ywx_software@foxmail.com" title="wechat">wechat</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-111测试的" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/15/111测试的/" class="article-date">
      <time datetime="2017-10-15T06:12:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/15/111测试的/">我是测试的先占的以后改</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>js中常用的继承方式: 子类继承父类的方法：</p>
<h3 id="1、原型继承"><a href="#1、原型继承" class="headerlink" title="1、原型继承"></a>1、原型继承</h3><p>子类的原型指向父类的一个实例  父类的私有和公有方法都是子类的公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 100;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getX = function ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function B()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = new A(); //B的原型重新赋值A的实例==&gt;每个b实例都能通过自己的__proto__找到a上的所有的私有方法，并且还可以通过a.__proto__继续找到A.prototype上的所有属性 ==&gt; A这个类上的方法相对于B都是公有方法</span><br><span class="line">B.prototype.constructor = B; //由于重新修改了B的原型导致默认原型上的constructor丢失，我们需要自己添加上</span><br></pre></td></tr></table></figure></p>
<h3 id="2、call继承"><a href="#2、call继承" class="headerlink" title="2、call继承"></a>2、call继承</h3><p>在子类构造函数中 父类.call(this)  父类的私有变成子类的私有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">    this.x = 100; //d.x = 100</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function D()&#123;</span><br><span class="line">    C.call(this); //构造函数中的this就是当前实例  this ==&gt; d     C.call(d);  ==&gt; 把C中的this修改成d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、冒充对象继承"><a href="#3、冒充对象继承" class="headerlink" title="3、冒充对象继承"></a>3、冒充对象继承</h3><p>循环遍历父类实例，然后父类实例的私有方法全部拿过来添加给子类实，如果不做hasOwnProperty判断那么就是把父类的公有的和私有的都拿过来当私有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function E()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">    this.y = 200;</span><br><span class="line">&#125;</span><br><span class="line">E.prototype.getX = function ()&#123;&#125;</span><br><span class="line">function F()&#123;</span><br><span class="line">    var e = new E(); //e.x = 100;</span><br><span class="line">    for(var attr in e)&#123; //for in可以遍历到原型上的公有自定义属性</span><br><span class="line">        //attr = x</span><br><span class="line">        if(e.hasOwnProperty(attr))&#123; //如果这个判断不加，那么无论是公有的还是私有的都拿过来当私有的</span><br><span class="line">            this[attr] = e[attr];</span><br><span class="line">            //f[&apos;x&apos;] = e[&apos;x&apos;] ==&gt; f.x = 100;</span><br><span class="line">        &#125;</span><br><span class="line">        // e.propertyIsEnumerable() //可枚举属性  ==&gt; 简单理解：可以拿出来一一列举的属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-混合继承"><a href="#4-混合继承" class="headerlink" title="4 混合继承"></a>4 混合继承</h3><p>原型+call  ==&gt; 无论是私有的还是公有的都拿过来了 ==&gt; 子类的原型上的多了一套父类私有属但是不会产生问题。因为子类的私有属性也有一套相同的通过call继承拿过来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function G()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">G.prototype.getX = function()&#123;&#125;;</span><br><span class="line">function H()&#123;</span><br><span class="line">    G.call(this);</span><br><span class="line">&#125;</span><br><span class="line">H.prototype = new G();</span><br><span class="line">H.prototype.constructor = H;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-中间件继承"><a href="#5-中间件继承" class="headerlink" title="5 中间件继承"></a>5 中间件继承</h3><p>M.prototype.<strong>proto</strong> = K.prototype;  把父类的公有的当作子类的公有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function K()&#123;</span><br><span class="line">    this.x = 100;</span><br><span class="line">&#125;</span><br><span class="line">k.prototype.getX = function ()&#123;&#125;;</span><br><span class="line">function M()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">M.prototype.__proto__ = K.prototype; //本来应该是直接指向Object.prototype。从K的原型上的__proto__也可以到Object.prototype==&gt; 在K.prototype上停留了下，K.prototype就是一个中间件  父类的公有当作子类的公有</span><br></pre></td></tr></table></figure></p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h3><p> Object.create(xx.prototype)方法  ==&gt; 是把xx.prototype当作别人家的原型  不兼容，只能找到父类原型的方法。父类的私有属性访问不到。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.name = &quot;ywx&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;;</span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">//寄生组合式继承实现方式如下：</span><br><span class="line">Child.prototype = Object.create(Parent.prototype);</span><br><span class="line">var child=new Child();</span><br><span class="line">console.log(child.eat());//只有找到父类原型上的方法</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/我是点位的以后改/">我是点位的以后改</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-windows" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/28/nginx-windows/" class="article-date">
      <time datetime="2017-04-28T08:50:18.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/nginx-windows/">Windows下Nginx的启动、停止等命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。</p>
<h4 id="1、启动："><a href="#1、启动：" class="headerlink" title="1、启动："></a>1、启动：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;start nginx</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe</div></pre></td></tr></table></figure>
<p>注：建议使用第一种，第二种会使你的cmd窗口一直处于执行中，不能进行其他命令操作。</p>
<h4 id="2、停止："><a href="#2、停止：" class="headerlink" title="2、停止："></a>2、停止：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s stop</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s quit</div></pre></td></tr></table></figure>
<p>注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。</p>
<h4 id="3、重新载入Nginx："><a href="#3、重新载入Nginx：" class="headerlink" title="3、重新载入Nginx："></a>3、重新载入Nginx：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reload</div></pre></td></tr></table></figure>
<p>当配置信息修改，需要重新载入这些配置时使用此命令。不重新启动不会生效。</p>
<h4 id="4、重新打开日志文件："><a href="#4、重新打开日志文件：" class="headerlink" title="4、重新打开日志文件："></a>4、重新打开日志文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx.exe -s reopen</div></pre></td></tr></table></figure>
<h4 id="5、查看Nginx版本："><a href="#5、查看Nginx版本：" class="headerlink" title="5、查看Nginx版本："></a>5、查看Nginx版本：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\server\nginx-1.0.2&gt;nginx -v</div></pre></td></tr></table></figure>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>注：以上C:\server\nginx-1.0.2需要改成自已nginx的安装目录。每次写路径太麻烦，可以把C:\server\nginx-1.0.2配置成环境变量，这样就不用每次都写路径了，在任意目录下打开git或者cmd直接执行命令，系统会自己在环境变量path中查找。在此做下特殊说明：window下就算nginx配置好了环境变量，有些命令（比如：nginx -s stop）也无法用，会报错。</p>
<p>一、在cmd中，逐步进入到nginx的安装目录，在此目录下执行那些命令都可以。一步步进安装目录如果麻烦，可以执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start /D E:\nginx\nginx-1.6.2 nginx -s start</div><div class="line">Windows下的话可以用start命令，/D参数指定起始目录，这样在执行nginx命令前重新设定了指定的目录。</div></pre></td></tr></table></figure></p>
<p>此时会cmd会自动把路径跳转到nginx的安装目录了，此时也可以执行命令了。</p>
<p>二、也可以在安装目录下打开git,输入./nginx按回车，即启动了nginx,再按ctrl+c关闭nginx.</p>
<p>三、可以双击nginx.exe启动nginx,当修改了nginx.conf配置文件时，此时要重启，先在任务管理器中结束nginx的进程（打开任务管理器，输入英文字母n，可以快速定位到以n开头的应用，方便查找了），然后在双击运行nginx。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-nginx-configuration-start" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/nginx-configuration-start/" class="article-date">
      <time datetime="2017-04-26T08:34:27.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/nginx-configuration-start/">Nginx 配置简述</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>不论是本地开发，还是远程到 Server 开发，还是给提供 demo 给人看效果，我们时常需要对 Nginx 做配置，Nginx 的配置项相当多，如果考虑性能配置起来会比较麻烦。不过，我们往往只是需要一个静态 Server，或者一个反向代理 Server，这对 Nginx 来说小菜一碟。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Nginx 的安装就不解释了，方便起见，也可以在各平台可以直接执行对应安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># CentOS</div><div class="line">yum install nginx;</div><div class="line"># Ubuntu</div><div class="line">sudo apt-get install nginx;</div><div class="line"># Mac</div><div class="line">brew install nginx;</div></pre></td></tr></table></figure></p>
<p>常用的设置一般可以在 /etc/nginx/nginx.conf 中配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">下面是linux下的启动参数（windows的启动命令和其不一样）：</div><div class="line"># 启动</div><div class="line">nginx -s start;</div><div class="line"># 重新启动，热启动，修改配置重启不影响线上</div><div class="line">nginx -s reload;</div><div class="line"># 关闭</div><div class="line">nginx -s stop;</div><div class="line"># 修改配置后，可以通过下面的命令测试是否有语法错误</div><div class="line">nginx -t;</div></pre></td></tr></table></figure></p>
<p>-s，signal，意思就是向 nginx 发送 start|reload|stop 命令，还是很好理解的。先看一个最简单的 nginx.conf 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 需要保留这一个段落，可以为空</div><div class="line">    # 为注释的意思</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        location / &#123;</div><div class="line">            root /home/webywx/test/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动后，访问 <a href="http://127.0.0.1:8888" target="_blank" rel="external">http://127.0.0.1:8888</a> ，如果 /home/webywx/test/ 下有 index.html 文件就会展示 index.html 的内容，否则返回 404。</p>
<h4 id="Nginx-配置一个-Web-服务器"><a href="#Nginx-配置一个-Web-服务器" class="headerlink" title="Nginx 配置一个 Web 服务器"></a>Nginx 配置一个 Web 服务器</h4><p>以下是对配置 Web 服务器的参数做简单说明，包括如何配置端口、域名，如何处理请求，如何响应请求。</p>
<p>1、 虚拟主机和请求的分发<br>域名和端口的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">listen 127.0.0.1:8000;</div><div class="line">listen *:8000;</div><div class="line">listen localhost:8000;</div><div class="line"># IPV6</div><div class="line">listen [::]:8000;</div><div class="line"># other params</div><div class="line">listen 443 default_serer ssl;</div><div class="line">listen 127.0.0.1 default_server accept_filter=dataready backlog=1024</div></pre></td></tr></table></figure></p>
<p>主机名配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server_name www.webywx.com webywx.com</div><div class="line">server_name *.webywx.com</div><div class="line">server_name ~^\.web\.com$</div></pre></td></tr></table></figure></p>
<p>URI 匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location = / &#123;</div><div class="line">    # 完全匹配  =</div><div class="line">    # 大小写敏感 ~</div><div class="line">    # 忽略大小写 ~*</div><div class="line">&#125;</div><div class="line">location ^~ /images/ &#123;</div><div class="line">    # 前半部分匹配 ^~</div><div class="line">    # 可以使用正则，如：</div><div class="line">    # location ~* \.(gif|jpg|png)$ &#123; &#125;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 如果以上都未匹配，会进入这里</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 文件路径的定义<br>根目录设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root /home/webywx/test/;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>别名设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    alias /home/webywx/www/blog/;</div><div class="line">&#125;</div><div class="line">location ~ ^/blog/(\d+)/([\w-]+)$ &#123;</div><div class="line">    alias /home/webywx/www/blog/$1-$2.md;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首页设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index /html/index.html /php/index.php;</div></pre></td></tr></table></figure></p>
<p>重定向页面设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">error_page    404         /404.html;</div><div class="line">error_page    502  503    /50x.html;</div><div class="line">error_page    404  =200   /1x1.gif;</div><div class="line">location / &#123;</div><div class="line">    error_page  404 @fallback;</div><div class="line">&#125;</div><div class="line">location @fallback &#123;</div><div class="line">    # 将请求反向代理到上游服务器处理</div><div class="line">    proxy_pass http://localhost:9000;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>try_files 设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try_files $uri $uri.html $uri/index.html @other;</div><div class="line">location @other &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，失败了就会转到上游处理</div><div class="line">    proxy_pass  http://localhost:9000;</div><div class="line">&#125;</div><div class="line">location / &#123;</div><div class="line">    # 尝试寻找匹配 uri 的文件，没找到直接返回 502</div><div class="line">    try_files $uri $uri.html =502;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Nginx-配置反向代理服务器"><a href="#Nginx-配置反向代理服务器" class="headerlink" title="Nginx 配置反向代理服务器"></a>Nginx 配置反向代理服务器</h4><p>反向代理（reserve proxy）方式是指用代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络中的上游服务器，并将上游服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外的表现就是一个 Web 服务器。</p>
<p>Nginx 具备超强的高并发高负载能力，一般会作为前端的服务器直接向客户端提供静态文件服务；而业务一般还包含一些业务逻辑需要 Apache、Tomcat 等服务器来处理，故通常 Nginx 对外表现即为静态 Web 服务器也是反向代理服务器。</p>
<p>缺点是增加了一次请求的处理时间，优点是降低了上游服务器的负载，尽量将压力放在 Nginx 服务器上。</p>
<p>1、负载均衡配置<br>upstream，定义一个上游服务器集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">upstream backend &#123;</div><div class="line">    # ip_hash;</div><div class="line">    server s1.webywx.com;</div><div class="line">    server s2.webywx.com;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://backend;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、反向代理<br>proxy_pass 将请求转发到有处理能力的端上，默认不会转发请求中的 Host 头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">location /blog &#123;</div><div class="line">    prox_pass http://localhost:9000;</div><div class="line">    ### 下面都是次要关注项</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_method POST;</div><div class="line">    # 指定不转发的头部字段</div><div class="line">    proxy_hide_header Cache-Control;</div><div class="line">    proxy_hide_header Other-Header;</div><div class="line">    # 指定转发的头部字段</div><div class="line">    proxy_pass_header Server-IP;</div><div class="line">    proxy_pass_header Server-Name;</div><div class="line">    # 是否转发包体</div><div class="line">    proxy_pass_request_body on | off;</div><div class="line">    # 是否转发头部</div><div class="line">    proxy_pass_request_headers on | off;</div><div class="line">    # 显形/隐形 URI，上游发生重定向时，Nginx 是否同步更改 uri</div><div class="line">    proxy_redirect on | off;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="一个简单的例子，Node-js"><a href="#一个简单的例子，Node-js" class="headerlink" title="一个简单的例子，Node.js"></a>一个简单的例子，Node.js</h4><p>一个十分常见的需求：处理请求，如果是静态文件，Nginx 直接返回，否则交给 Node 服务器处理。首先创建了一个 Node 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const http = require(&apos;http&apos;);</div><div class="line">http.createServer((req, res) =&gt; &#123;</div><div class="line">    res.end(&apos;hello world&apos;);</div><div class="line">&#125;).listen(9000);</div></pre></td></tr></table></figure></p>
<p>任何请求过来都返回 hello world，简版的 Nginx 配置如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">events &#123;</div><div class="line">    # 这里可不写东西</div><div class="line">    use epoll;</div><div class="line">&#125;</div><div class="line">http &#123;</div><div class="line">    server &#123;</div><div class="line">        listen 127.0.0.1:8888;</div><div class="line">        # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">        try_files $uri $uri/index.html;</div><div class="line">        location ~* ^/(js|css|image|font)/$ &#123;</div><div class="line">            # 静态资源都在 static 文件夹下</div><div class="line">            root /home/webywx/www/static/;</div><div class="line">        &#125;</div><div class="line">        location /app &#123;</div><div class="line">            # Node.js 在 9000 开了一个监听端口</div><div class="line">            proxy_pass http://127.0.0.1:9000;</div><div class="line">        &#125;</div><div class="line">        # 上面处理出错或者未找到的，返回对应状态码文件</div><div class="line">        error_page    404            /404.html;</div><div class="line">        error_page    502  503  504  /50x.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先 try_files，尝试直接匹配文件；没找到就匹配静态资源；还没找到就交给 Node 处理；否则就返回 4xx/5xx 的状态码。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>边学边动手尝试，利用 nginx -t 测试语法，遇到问题就 Google 搜索下，上手应该还是很快的。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-interview-css" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/26/interview-css/" class="article-date">
      <time datetime="2017-04-26T07:10:31.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/26/interview-css/">前端笔试面试中的常用到的CSS知识点总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在前端开发领域，CSS是比较特殊的一种存在。理论上说，它是一种属性大杂烩，并不属于编程语言的范畴，当然SASS和LESS这两种预编译机制除外。所以CSS的学习是需要不断地去记忆和积累的。在前端笔试和面试过程中，CSS的考察是比较琐碎的，而且往往考察点比较偏，需要我们平时养成积累的习惯。</p>
<h4 id="1、CSS选择器的优先级"><a href="#1、CSS选择器的优先级" class="headerlink" title="1、CSS选择器的优先级"></a>1、CSS选择器的优先级</h4><p>!important &gt; 内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器<br>多个类选择器叠加（256）之后的优先级大于一个id选择器<br>!important 用于强调CSS属性具有最高的优先级。IE6不支持这种用法。<br>CSS选择器的种类：<br>1.id选择器(# myid)<br>2.类选择器(.myclassname)<br>3.标签选择器(div, h1, p)<br>4.相邻选择器(h1 + p)<br>5.子选择器(ul &gt; li)<br>6.后代选择器(li a)<br>7.通配符选择器( * )<br>8.属性选择器(a[rel = “external”])<br>9.伪类选择器(a: hover, li:nth-child)</p>
<h4 id="2、CSS优先级权重计算法"><a href="#2、CSS优先级权重计算法" class="headerlink" title="2、CSS优先级权重计算法"></a>2、CSS优先级权重计算法</h4><p>CSS优先级的计算规则如下：<br>元素标签中定义的样式（Style属性）,加1,0,0,0<br>每个ID选择符(如 #id),加0,1,0,0<br>每个Class选择符、每个属性选择符、每个伪类（:hover）加0,0,1,0<br>每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1<br>然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值<br>然后从左到右逐位比较大小，数字大的CSS样式的优先级就高。<br>前一等级相等才往后比，依次类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">例如果样式中有两个id选择符，则为0,2,0,0;</div><div class="line">#div1 #div2&#123;</div><div class="line">color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"><a href="#3、超链接访问过后hover样式就不出现的问题是什么？如何解决？" class="headerlink" title="3、超链接访问过后hover样式就不出现的问题是什么？如何解决？"></a>3、超链接访问过后hover样式就不出现的问题是什么？如何解决？</h4><p>被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）,为了便于记忆，可以记love hate;</p>
<h4 id="4、什么是Css-Hack？ie6-7-8的hack分别是什么？"><a href="#4、什么是Css-Hack？ie6-7-8的hack分别是什么？" class="headerlink" title="4、什么是Css Hack？ie6,7,8的hack分别是什么？"></a>4、什么是Css Hack？ie6,7,8的hack分别是什么？</h4><p>针对不同的浏览器写不同的CSS code的过程，就是CSS hack。常见的hack手法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#test   &#123;   </div><div class="line">        width:300px;   </div><div class="line">        height:300px;   </div><div class="line">        background-color:blue;      /*firefox*/</div><div class="line">        background-color:red\9;      /*all ie*/</div><div class="line">        background-color:yellow\0;    /*ie8*/</div><div class="line">        +background-color:pink;        /*ie7*/</div><div class="line">        _background-color:orange;       /*ie6*/    &#125;  </div><div class="line">        :root #test &#123; background-color:purple\9; &#125;  /*ie9*/</div><div class="line">    @media all and (min-width:0px)&#123; </div><div class="line">          #test &#123;background-color:black\0;&#125; </div><div class="line">     &#125;  /*opera*/</div><div class="line">    @media screen and (-webkit-min-device-pixel-ratio:0)&#123; </div><div class="line">#test &#123;background-color:gray;&#125; </div><div class="line">&#125;       /*chrome and safari*/</div></pre></td></tr></table></figure></p>
<h4 id="5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？"><a href="#5、描述一个”reset”的CSS文件并如何使用它。知道normalize-css吗？你了解他们的不同之处？" class="headerlink" title="5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？"></a>5、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？</h4><p>不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。<br>你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p>
<h4 id="6、display-none与visibility-hidden的区别是什么？"><a href="#6、display-none与visibility-hidden的区别是什么？" class="headerlink" title="6、display:none与visibility:hidden的区别是什么？"></a>6、display:none与visibility:hidden的区别是什么？</h4><p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br>即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>
<h4 id="7、CSS盒子模型"><a href="#7、CSS盒子模型" class="headerlink" title="7、CSS盒子模型"></a>7、CSS盒子模型</h4><p>Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。盒子模型有 block,inline-block,inline,flex,table-cell等几种显示方式。</p>
<p><div align="center"><br>    <img src="http://oi28tswuq.bkt.clouddn.com/images/box-model.png-public" alt=""><br></div><br>如上图所示，元素的高度和宽度指的是盒子模型的content区域的高度和宽度，不包括内边距以外的部分，这就是标准的盒模型（它的宽高就是指content区）。但盒子模型有两种，W3C标准盒子模型（content-box）以及IE盒子模型（border-box），IE盒模型又称怪异盒模型（它的宽高包含border、内边距和content）。</p>
<h4 id="8、相对定位relative、浮动float以及绝对定位absolute的区别？"><a href="#8、相对定位relative、浮动float以及绝对定位absolute的区别？" class="headerlink" title="8、相对定位relative、浮动float以及绝对定位absolute的区别？"></a>8、相对定位relative、浮动float以及绝对定位absolute的区别？</h4><p>1）相对定位是在常规流中的定位。一旦一个框按照常规流或者是浮动得到定位，它还可以相对该位置而偏移， 这就是相对定位。偏移后，在常规流中依然占据原有位置，偏移量并不会对后续的block产生挤占，后续的块就好像没有感知到偏移，依然按照常规流位置排位。<br>2）绝对定位（Absolute positioning）元素定位的参照物是其包含块（第一个relative定位的祖先元素）进行定位，不一定是其父元素。绝对定位元素完全脱离了常规流，每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。绝对元素定位的 top 和 left 值跟绝对元素未脱离常规流之前在常规流中位置有关。<br>3）浮动框就是一个框在当前行被向左或向右挪动(偏移)，它不在常规流中。在该浮动框之前或之后创建的非定位框垂直排列，就好象浮动框并不存在一样。当前行里浮动框前的任何内容，都将被重新排列到该浮动另一侧的第一个可用行里。</p>
<h4 id="9、清除浮动的用法？"><a href="#9、清除浮动的用法？" class="headerlink" title="9、清除浮动的用法？"></a>9、清除浮动的用法？</h4><p>在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。<br>使用方法：<br>1、在浮动元素后使用一个空元素如<br>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。<br>2、给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动<br>3、什么都不做，给浮动元素后面的元素添加clear属性。<br>4、利用伪类清除浮动，给浮动元素的容器添加一个clearfix的class，然 后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//一种常见利用伪类清除浮动的代码</div><div class="line"> .clearfix:after &#123;</div><div class="line">    content:&quot;.&quot;;       //这里利用到了content属性</div><div class="line">    display:block; </div><div class="line">    height:0;</div><div class="line">    visibility:hidden; </div><div class="line">    clear:both; </div><div class="line">&#125;</div><div class="line">.clearfix &#123; </div><div class="line">    *zoom:1; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"><a href="#10、BOX模型的margin在IE比在其他浏览器大2px的解决办法" class="headerlink" title="10、BOX模型的margin在IE比在其他浏览器大2px的解决办法"></a>10、BOX模型的margin在IE比在其他浏览器大2px的解决办法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div&#123;margin:30px!important;margin:28px;&#125;</div></pre></td></tr></table></figure>
<p>注意这两个margin的顺序一定不能写反，!important这个 属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样：<br>div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;<br>也可以用hack写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div &#123; _margin:28px;margin:28px\9;margin:30px;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="11、IE-3像素Bug的产生原因及解决办法"><a href="#11、IE-3像素Bug的产生原因及解决办法" class="headerlink" title="11、IE 3像素Bug的产生原因及解决办法"></a>11、IE 3像素Bug的产生原因及解决办法</h4><p>当在同一行相邻出现一个浮动的块元素和一个非浮动的块元素时，两块元素之间就会出现3px的裂痕。<br>解决办法就是：对其中一个元素添加“_margin-*:-3px”的CSS属性，或者将另外一个非浮动的元素设为浮动。</p>
<h4 id="12、IE6-双边距Bug的产生原因及解决办法"><a href="#12、IE6-双边距Bug的产生原因及解决办法" class="headerlink" title="12、IE6 双边距Bug的产生原因及解决办法"></a>12、IE6 双边距Bug的产生原因及解决办法</h4><p>当我们在浮动元素上面添加margin-*的属性的时候，比如在float:left的元素CSS添加margin-left:50px，那么最终在IE6下面的显示就是该元素的margin-left最终变为100px，边距翻倍。<br>解决办法：添加_display:inline</p>
<h4 id="13、文本溢出省略的处理方法"><a href="#13、文本溢出省略的处理方法" class="headerlink" title="13、文本溢出省略的处理方法"></a>13、文本溢出省略的处理方法</h4><p>1)单行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.inline&#123;</div><div class="line">  overflow:hidden;</div><div class="line">         white-space:nowrap;</div><div class="line">         text-overflow:ellipsis; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2)多行文本溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.foo&#123;</div><div class="line">  display:-webkit-box!important;</div><div class="line">  overflow:hidden;</div><div class="line">  text-overflow:ellipsis;</div><div class="line">  work-break:break-all;</div><div class="line">  -webkit-box-orient:vertical; /*方向*/</div><div class="line">  -webkit-line-clamp:4; /*显示多少行文本*/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这里只适用于webkit内核浏览器，不兼容IE和其他非webkit浏览器。</p>
<h4 id="14、CSS实现垂直水平居中"><a href="#14、CSS实现垂直水平居中" class="headerlink" title="14、CSS实现垂直水平居中"></a>14、CSS实现垂直水平居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法1：</div><div class="line">.parent &#123;</div><div class="line">          width:800px;</div><div class="line">          height:500px;</div><div class="line">          border:2px solid #000;</div><div class="line">          position:relative;</div><div class="line">&#125;</div><div class="line"> .child &#123;</div><div class="line">        width:200px;</div><div class="line">        height:200px;</div><div class="line">        margin: auto;  </div><div class="line">        position: absolute;  </div><div class="line">        top: 0; left: 0; bottom: 0; right: 0; </div><div class="line">        background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方法2：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:table-cell;</div><div class="line">    vertical-align:middle;</div><div class="line">    text-align: center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    display:inline-block;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">方法3：</div><div class="line">.parent &#123;</div><div class="line">    width:800px;</div><div class="line">    height:500px;</div><div class="line">    border:2px solid #000;</div><div class="line">    display:flex;</div><div class="line">    justify-content:center;</div><div class="line">    align-items:center;</div><div class="line">&#125;</div><div class="line">.child &#123;</div><div class="line">    width:200px;</div><div class="line">    height:200px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">方法4：</div><div class="line">.parent &#123;</div><div class="line">        width:800px;</div><div class="line">        height:500px;</div><div class="line">        border:2px solid #000;</div><div class="line">        position:relative;</div><div class="line">    &#125;</div><div class="line">.child &#123;</div><div class="line">    width:300px;</div><div class="line">    height:200px;</div><div class="line">    margin:auto;</div><div class="line">    position:absolute;</div><div class="line">//设定水平和垂直偏移父元素的50%，</div><div class="line">//再根据实际长度将子元素上左挪回一半大小</div><div class="line">    left:50%;</div><div class="line">    top:50%;</div><div class="line">    margin-left: -150px;</div><div class="line">    margin-top:-100px;</div><div class="line">    background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="15、BFC"><a href="#15、BFC" class="headerlink" title="15、BFC"></a>15、BFC</h4><p>块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。<br>BFC的创建方法：<br>根元素或其它包含它的元素；<br>浮动 (元素的float不为none)；<br>绝对定位元素 (元素的position为absolute或fixed)；<br>行内块inline-blocks(元素的 display: inline-block)；<br>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；<br>overflow的值不为visible的元素；<br>弹性盒 flex boxes (元素的display: flex或inline-flex)；</p>
<h4 id="16、响应式图片的CSS"><a href="#16、响应式图片的CSS" class="headerlink" title="16、响应式图片的CSS"></a>16、响应式图片的CSS</h4><p>所谓响应式图片，就是根据图片所在容器的大小来实时地按比例缩放。实现的办法非常简单，只需要设置img标签的width:100%即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">width:100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 max-width 属性设置为 100%, 图片永远不会大于其原始大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img &#123;</div><div class="line">max-width: 100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="17、CSS响应式网格系统原理"><a href="#17、CSS响应式网格系统原理" class="headerlink" title="17、CSS响应式网格系统原理"></a>17、CSS响应式网格系统原理</h4><p>总的来说，网格系统就是利用百分比把视口等分为12个，然后利用float属性使之并列显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    box-sizing: border-box;</div><div class="line">&#125;</div><div class="line">[class*=&quot;col-&quot;] &#123;</div><div class="line">    float: left;</div><div class="line">    padding: 15px;</div><div class="line">    border: 1px solid red;</div><div class="line">&#125;</div><div class="line">.col-1 &#123;width: 8.33%;&#125;</div><div class="line">.col-2 &#123;width: 16.66%;&#125;</div><div class="line">.col-3 &#123;width: 25%;&#125;</div><div class="line">.col-4 &#123;width: 33.33%;&#125;</div><div class="line">.col-5 &#123;width: 41.66%;&#125;</div><div class="line">.col-6 &#123;width: 50%;&#125;</div><div class="line">.col-7 &#123;width: 58.33%;&#125;</div><div class="line">.col-8 &#123;width: 66.66%;&#125;</div><div class="line">.col-9 &#123;width: 75%;&#125;</div><div class="line">.col-10 &#123;width: 83.33%;&#125;</div><div class="line">.col-11 &#123;width: 91.66%;&#125;</div><div class="line">.col-12 &#123;width: 100%;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="18、用LESS循环实现栅格类"><a href="#18、用LESS循环实现栅格类" class="headerlink" title="18、用LESS循环实现栅格类"></a>18、用LESS循环实现栅格类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.generate-columns(12);</div><div class="line">.generate-columns(@n; @i: 1) when (@i =&lt; @n) &#123;</div><div class="line">  .column-@&#123;i&#125; &#123;</div><div class="line">    width: (@i * 100% / @n);</div><div class="line">  &#125;</div><div class="line">.generate-columns(@n, (@i + 1));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="19、使用perspective属性和transform：perspective-函数的区别"><a href="#19、使用perspective属性和transform：perspective-函数的区别" class="headerlink" title="19、使用perspective属性和transform：perspective()函数的区别"></a>19、使用perspective属性和transform：perspective()函数的区别</h4><p>以上的两种书写格式都会生成一个3D立体效果，但是它们之间有一些区别。使用功能函数的方式可以很方便的在单个元素上应用3D transform，但是当在多个元素上使用时，转换的元素不会得到预期的效果。如果你为不同的元素使用相同的transform，每一个元素都会有自己的消失点。为了解决这个问题，可以在父元素上使用perspective属性，这样，所有的子元素都可以共享同一个3D空间。<br>perspective-origin: 25% 75%，等价于perspective-origin x和perspective-origin y的合体，用来设置镜头聚焦点的位置(舞台中心)<br>transform-style: preserve-3d,transform-style属性也是3D效果中经常使用的，其两个参数，flat|preserve-3d. 前者flat为默认值，表示平面的；后者preserve-3d表示3D透视。<br>backface-visibility：hidden|visibility设置背后元素是否可见</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css-前端开发/">css 前端开发</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-flexintroduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/20/flexintroduction/" class="article-date">
      <time datetime="2017-02-20T03:09:43.000Z" itemprop="datePublished">2017-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/20/flexintroduction/">学习flex布局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<h4 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h4><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>行内元素也可以使用Flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Webkit内核的浏览器，必须加上-webkit前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: -webkit-flex; /* Safari */</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h4><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h4 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h4><p>以下6个属性设置在容器上。<br>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p>
<p>更多学习内容参考以下链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex-css3/">flex css3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-rengemianju" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/19/rengemianju/" class="article-date">
      <time datetime="2017-02-19T09:32:10.000Z" itemprop="datePublished">2017-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/19/rengemianju/">人格面具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>村上春树在《海边的卡夫卡》里这样写道：“我相信所谓的命运不过是一个人的生理、心理、情感、性格等等因素所造成的一个人行动的最终结果。我也始终相信这些因素都是可以人为改变的。”</p>
<p>就像我们总是抱怨越长大越发现知人知面不知心，可当我们握着无数个面具在不同情境下快速扮演一个适宜的角色，把真实的自己隐藏在重重厚茧之下时，又有几点真实？</p>
<p>我们对生活展现的态度，也就是生活在我们身上映射的样子。</p>
<h4 id="人格面具"><a href="#人格面具" class="headerlink" title="人格面具"></a>人格面具</h4><p>之前又被吐槽高冷，已经习以为常，我曾经也琢磨过，我哪里高冷了？要不要改变一下显得更有亲和力？试图“矫正”过，不过最别扭的是自己，我是一个十分看重边界的人，确实没办法在不了解彼此的情况下“自来熟”般地表现热络和亲昵，索性作罢。</p>
<p>有人愿意给我贴上“高冷”标签，或者因此疏远，我也并不觉得可惜。别人对你有什么样的印象，并不都是准确的，而每个人看到的也未必都是一个人本来的样子。</p>
<p>这层表象，就是所谓的“人格面具”。我们并不总是时刻表现出真实的自我，有时囿于环境差异，有时囿于对象的不同。我们需要这层面具的保护，它带给我们游刃有余的安全感，让我们在不同情境下能更快适应和融入，并且感到舒服。</p>
<p>我们每个人都是这样，人前人后判若两人，把不适合展现于人前的东西妥善收好，在某个独自面对自己的时刻才肯摘掉面具，才肯让个性中被压抑的部分舒展和释放。</p>
<h4 id="你看到的未必就是真实，你以为的也不过就是你以为而已。"><a href="#你看到的未必就是真实，你以为的也不过就是你以为而已。" class="headerlink" title="你看到的未必就是真实，你以为的也不过就是你以为而已。"></a>你看到的未必就是真实，你以为的也不过就是你以为而已。</h4><p>而一旦人格面具戴久了，或许自己都不太习惯看见自己最真实的一面，我们越来越适应外部世界的各种情境。我们在人前越来越游刃有余地表演别人需要的样子，有时甚至把这层表象误以为是真正的自己，这是一种无奈。</p>
<p>更何况，人格面具从来不止一个。面对同事、家人、朋友、爱人、陌生人、敌人，面对工作、聚会、约会、谈判、交涉，每一个不同的人，每一个不同的场景，我们的内心都有一种预设，该表现怎么样的自我，该说怎样的话，都有它该匹配的剧本。就像不同场合适合不同着装一样，我们挑选着适合的衣服，也挑选着适合的人格面具，这是“社会化”的过程必不可少的一步。</p>
<p>人心是比宇宙还浩瀚的地方，而人的复杂性远超任何科学，它没有公式可以计算，也没有精确的工具可以测量。我们都是在一寸一寸地体验自己人格中的维度，比喻成盲人摸象也不为过，个性就是有很多面，它是立体的、富有弹性的、充满奥秘的。</p>
<h4 id="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"><a href="#推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。" class="headerlink" title="推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。"></a>推己及人，如果你能看到自己身上的多面复杂性，对待他人便会有不一样的宽阔眼光。</h4><p>我经历过怒目相视的时刻，但想到这双眼或许对别人温柔如水过，刚要燃起的愤怒也就悄悄熄灭了；我也担心过疲惫困顿的身影，但我相信这只是一个停顿，总有些力量会支撑他走下去，所以会用鼓励替代心疼；而那些看似放荡不羁的灵魂，也总会有珍视和在意的人和事，便不再羡慕他那表面的轻松和无谓了。</p>
<p>我们体验到的只是对方转眼消失的一瞬，而对面的那个人却经历了无数个人生厚重的瞬间；我们看到的只是一个人的一面，而这个人其实跟自己一样，也不过是在诸多人格维度中展现了其中之一罢了。</p>
<p>人们总是习惯在不了解对方的时候，就用一些标签和自以为是的评价为对方打上一个烙印，还往往以为这就是确定的真实。用这种似是而非的“确定性”否定了所有的可能性，或许才是人与人相处的最大障碍。</p>
<p>有时候，不是命运缺少安排，也不是缘分太浅，只是你没有给别人时间和空间展示更丰富真实的自己，才同样让自己也错失了机会。又或者我们习惯了面具的存在，也快忘记了在别人靠近的时候，松动和敞开自己的内心，给他一个走进自己生活的机会。</p>
<p>原来，每个人都不是你看到的那个样子，原来，每个人都需要一个真正认识彼此的机会。——注：文章参考于网络，仅供个人学习</p>
<p>最后送大家一句话：真正支撑一个人活下去的不是安逸，而是对生活的不甘。我要经历一切，哪怕不完美！！！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-lovestart" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/14/lovestart/" class="article-date">
      <time datetime="2017-02-14T09:15:48.000Z" itemprop="datePublished">2017-02-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/14/lovestart/">爱的开始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <iframe style="margin:0 auto; display:block;" frameborder="no" border="0" marginwidth="0" marginheight="0" width="530" height="86" src="//music.163.com/outchain/player?type=2&id=27731261&auto=1&height=66"></iframe>

<p>2017年2月12日，在金莎鹿港小镇我们第一次相见。你迟到了（说好的11点，你临时修网线11点半多到的），按照国际惯例我应该是不耐烦了，因为我很讨厌迟到的人，除非是有不可控因素。一些可控因素的迟到在一定程序上说明没有引起对方足够的重视。但是那一刻我清楚地记得我很有耐心，说实话我都佩服我自己，我也不知道我哪来的耐心，大概是直觉告诉我你就是那个对的人。</p>
<p>饭前，我一个人在麦当劳静静地听着音乐，怀着一种期盼地心情等待你的出现。</p>
<p>饭间，通过简单地沟通我更加明确了方向，你就是我要等的那个人。吸引我的地方就是不但人美，而且还透露着一种独特的气质。此处应该有一个大写的表情：奸笑。</p>
<p>饭毕，我们去了八大处，说说笑笑走着上去的，安安静静地坐揽车下来的。期间，看到你儿童般地步伐、天真灿烂的笑容，我心里油然而生一种幸福感，仿佛回到了童年。</p>
<p>都说欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。我能告诉你们在这一天我用火眼金睛都看到了吗？答案是不能也得能。此刻让我想起来汪国真的一首诗：我不去想是否能够成功，既然选择了远方，便只顾风雨兼程！我不去想能否赢得爱情，既然钟情于玫瑰，就勇敢地吐露真诚。</p>
<p>爱不是交易，爱也不是要求，爱是不求回报地付出，爱是相互欣赏与理解对方。愿能用我的真心换来你的实意，你若不离，我定不弃。最后贴上一句我很喜欢的话：但行好事，莫问前程，欢迎你和我一起，成为很酷的年轻人。</p>
<h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>记得之前通话期间我问过你的生日，在此记录下来，阴历11月29，我想到时候应该会有一个惊喜。</p>
<p>17年2月 26日晚，我第一次认真地生气，是因为第一回打电话没人接，第二回打正在通话中，足足等了快一小时居然还没有回个电话，我本决定那天晚上不再给你打电话，但是我没有忍住，最终还是又打了。见了你之后对你就有一种说不出的感觉，那种感觉就像磁场，而磁场里只有你我共存。为了你我内心愿意放下从前的自己，对待你的态度和别人的就是不一样，这也不是我特意去做的，只是我内心的一种选择。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活/">生活</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-web-workers" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/10/web-workers/" class="article-date">
      <time datetime="2017-02-10T03:53:05.000Z" itemprop="datePublished">2017-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/10/web-workers/">程序性能之HTML5 Web Workers</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="什么是-Web-Worker？"><a href="#什么是-Web-Worker？" class="headerlink" title="什么是 Web Worker？"></a>什么是 Web Worker？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>大家都知道JavaScript是单线程运作的。但是，单线程并不是组织程序执行的唯一方式。可以设想一下，把你的程序分为两个部分： 一部分运行在主 UI 线程下， 另外一部分运行在另一个完全独立的线程中。<br>像浏览器这样的环境， 很容易提供多个 JavaScript 引擎实例， 各自运行在自己的线程上， 这样你可以在每个线程上运行不同的程序。 程序中每一个这样的独立的多线程部分被称为一个（ Web） Worker。 这种类型的并行化被称为任务并行 ，因为其重点在于把程序划分为多个块来并发运行。从 JavaScript 主程序（ 或另一个 Worker） 中， 可以这样实例化一个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new Worker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这个 URL应该指向一个 JavaScript 文件的位置（ 而不是一个 HTML页面！ ） ， 这个文件将被加载到一个 Worker 中。 然后浏览器启动一个独立的线程， 让这个文件在这个线程中作为独立的程序运行。这种通过这样的 URL创建的 Worker 称为专用 Worker（ Dedicated Worker） 。 除了提供一个指向外部文件的 URL， 你还可以通过提供一个 Blob URL（ 另外一个 HTML5 特性） 创建一个在线 Worker（ Inline Worker)， 本质上就是一个存储在单个（ 二进制） 值中的在线文件。</p>
<p>Worker 之间以及它们和主程序之间， 不会共享任何作用域或资源，  而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者， 可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>以下是如何侦听事件（ 其实就是固定的 “message” 事件） ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>也可以发送 “message” 事件给这个 Worker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.postMessage( &quot;something cool to say&quot; );</div></pre></td></tr></table></figure></p>
<p>在这个 Worker 内部， 收发消息是完全对称的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// &quot;mycoolworker.js&quot;</div><div class="line">addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// evt.data</div><div class="line">&#125; );</div><div class="line">postMessage( &quot;a really cool reply&quot; );//postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</div></pre></td></tr></table></figure></p>
<p>注意， 专用 Worker 和创建它的程序之间是一对一的关系。 也就是说， “message” 事件没有任何歧义需要消除， 因为我们确定它只能来自这个一对一的关系： 它要么来自这个 Worker， 要么来自主页面。<br>通常由主页面应用程序创建 Worker， 但若是需要的话， Worker 也可以实例化它自己的子 Worker， 称为 subworker。 有时候，把这样的细节委托给一个“主”Worker， 由它来创建其他 Worker 处理部分任务， 这样很有用。  要想使用subworker首先要确定浏览器是否支持。要在创建 Worker 的程序中终止 Worker， 可以调用 Worker 对象（ 就像前面代码中的 w1 ） 上的 terminate() 。 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。 这就类似于通过关闭浏览器标签页来关闭页面。<br>如果浏览器中有两个或多个页面（ 或同一页上的多个 tab ！ ） 试图从同一个文件 URL创建 Worker， 那么最终得到的实际上是完全独立的 Worker。</p>
<h4 id="Web-Worker-通常应用于哪些方面呢？"><a href="#Web-Worker-通常应用于哪些方面呢？" class="headerlink" title="Web Worker 通常应用于哪些方面呢？"></a>Web Worker 通常应用于哪些方面呢？</h4><p>处理密集型数学计算<br>大数据集排序<br>数据处理（ 压缩、 音频分析、 图像处理等）<br>高流量网络通信<br>注释：web worker 通常不用于过于简单的脚本，而是用于更耗费 CPU 资源的任务。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if(typeof(Worker)!==&quot;undefined&quot;)</div><div class="line">  &#123;</div><div class="line">  // Yes! Web worker support!</div><div class="line">  // Some code.....</div><div class="line">  &#125;</div><div class="line">else</div><div class="line">  &#123;</div><div class="line">  // Sorry! No Web Worker support..</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Worker环境"><a href="#Worker环境" class="headerlink" title="Worker环境"></a>Worker环境</h4><p>在 Worker 内部是无法访问主程序的任何资源的。 这意味着你不能访问它的任何全局变量， 也不能访问页面的 DOM 或者其他资源。 记住， 这是一个完全独立的线程。<br>但 是， 你可以执行网络操 作（ Ajax、 WebSockets） 以及设定定时 器。 还 有， Worker 可以访问几个重要的全局变量和功能的本地复本， 包括 navigator 、 location 、 JSON 和 applicationCache 。还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 在Worker内部</div><div class="line">importScripts( &quot;foo.js&quot;, &quot;bar.js&quot; );</div></pre></td></tr></table></figure></p>
<p>这些脚本加载是同步的。 也就是说， importScripts(..) 调用会阻塞余下 Worker 的执行， 直到文件加载和执行完成。</p>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>可能已经注意到这些应用中的大多数有一个共性， 就是需要在线程之间通过事件机制传递大量的信息， 可能是双向的。</p>
<p>如果要传递一个对象， 可以使用结构化克隆算法 （ structured clone algorithm） （ <a href="https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）" target="_blank" rel="external">https://developer.mozilla.org/enUS/docs/Web/Guide/API/DOM/The_structured_clone_algorithm）</a> 把这个对象复制到另一边。 这个算法非常高级， 甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string和 from-string的性能损失了， 但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。</p>
<p>还有一个更好的选择， 特别是对于大数据集而言， 就是使用 Transferable 对象 （ <a href="http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，" target="_blank" rel="external">http://updates.html5rocks.com/2011/12/TransferableObjects-Lightning-Fast)这时发生的是对象所有权的转移，</a> 数据本身并没有移动。 一旦你把对象传递到一个 Worker 中， 在原来的位置上， 它就变为空的或者是不可访问的， 这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双向进行的。</p>
<p>如果选择 Transferable 对象的话， 其实不需要做什么。 任何实现了 Transferable 接口（ <a href="http://developer.mozilla.org/enUS/docs/Web/API/Transferable" target="_blank" rel="external">http://developer.mozilla.org/enUS/docs/Web/API/Transferable</a> ）的数据结构就自动按照这种方式传输（ Firefox和 Chrome 都支持） 。举例来说， 像 Uint8Array这样的带类型的数组 就是Transferable。 下面是如何使用 postMessage(..) 发送一个 Transferable 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 比如foo是一个Uint8Array</div><div class="line">postMessage( foo.buffer, [ foo.buffer ] );</div></pre></td></tr></table></figure></p>
<p>第一个参数是一个原始缓冲区， 第二个是一个要传输的内容的列表。不支持 Transferable 对象的浏览器就降级到结构化克隆， 这会带来性能下降而不是彻底的功能失效。</p>
<h4 id="共享-Worker"><a href="#共享-Worker" class="headerlink" title="共享 Worker"></a>共享 Worker</h4><p>如果你的站点或 app 允许加载同一个页面的多个 tab（ 一个常见的功能） ， 那你可能非常希望通过防止重复专用 Worker 来降低系统的资源使用。 在这一方面最常见的有限资源就是 socket 网络连接， 因为浏览器限制了到同一个主机的同时连接数目。 当然， 限制来自于同一客户端的连接数也减轻了你的资源压力。<br>在这种情况下， 创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 SharedWorker ， 可通过下面的方式创建（ 只有 Firefox和 Chrome 支持这一功能）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var w1 = new SharedWorker( &quot;http://some.url.1/mycoolworker.js&quot; );</div></pre></td></tr></table></figure></p>
<p>因为共享 Worker 可以与站点的多个程序实例或多个页面连接， 所以这个 Worker 需要通过某种方式来得知消息来自于哪个程序。 这个唯一标识符称为端口 （ port） ， 可以类比网络 socket 的端口。 因此， 调用程序必须使用 Worker 的 port 对象用于通信:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1.port.addEventListener( &quot;message&quot;, handleMessages );</div><div class="line">// ..</div><div class="line">w1.port.postMessage( &quot;something cool&quot; );</div></pre></td></tr></table></figure></p>
<p>还有， 端口连接必须要初始化， 形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w1.port.start();</div></pre></td></tr></table></figure></p>
<p>在共享 Worker 内部， 必须要处理额外的一个事件： “connect” 。 这个事件为这个特定的连接提供了端口对象。 保持多个连接独立的最简单办法就是使用 port 上的闭包，就像下面的代码一样， 把这个链接上的事件侦听和传递定义在 “connect” 事件的处理函数内部：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 在共享Worker内部</div><div class="line">addEventListener( &quot;connect&quot;, function(evt)&#123;</div><div class="line">// 这个连接分配的端口</div><div class="line">var port = evt.ports[0];</div><div class="line">port.addEventListener( &quot;message&quot;, function(evt)&#123;</div><div class="line">// ..</div><div class="line">port.postMessage( .. );</div><div class="line">// ..</div><div class="line">&#125; );</div><div class="line">// 初始化端口连接</div><div class="line">port.start();</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>除了这个区别之外， 共享和专用 Worker 在功能和语义方面都是一样的.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Web Worker 让你可以在独立的线程运行一个 JavaScript 文件（ 即程序） ， 使用异步事件在线程之间传递消息。 它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程中，以提高主 UI 线程的响应性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/h5-webworkers/">h5 webworkers</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-deepthis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/07/deepthis/" class="article-date">
      <time datetime="2017-02-07T02:43:40.000Z" itemprop="datePublished">2017-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/07/deepthis/">关于this那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="this的简单理解"><a href="#this的简单理解" class="headerlink" title="this的简单理解"></a>this的简单理解</h4><p>this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call()、apply()和bind()用来改变this关键字的</div><div class="line">function.call(thisObj,参数1，参数2....)</div><div class="line">function.apply(thisObj,[参数1，参数2....])</div><div class="line">function.bind(thisObj，参数1,参数2...)</div></pre></td></tr></table></figure></p>
<p>call和apply改变this关键字时函数会被立即执行，而bind不会使函数立即执行，而是会创建一个新函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line"> this.count++;</div><div class="line">&#125; </div><div class="line">foo.count = 0; 函数是一个对象类型的，所以可以添加自定义属性。</div><div class="line">foo.call(foo);//这样foo.count=2,因为call把foo函数里的this指向foo本身。</div><div class="line">foo();//函数直接执行，函数里面的this指向window,所以foo.count还是为0;</div></pre></td></tr></table></figure></p>
<p>总结：this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p>
<h4 id="严格与非严格模式下的this"><a href="#严格与非严格模式下的this" class="headerlink" title="严格与非严格模式下的this"></a>严格与非严格模式下的this</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // 2，此时函数里的this默认指向全局window。</div></pre></td></tr></table></figure>
<p>如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">foo(); // TypeError: this is undefined</div></pre></td></tr></table></figure></p>
<p>虽然 this 的绑定规则完全取决于调用位置， 但是只有 foo() 运行在非 strict mode 下时， 默认绑定才能绑定到全局对象； 严格模式下与 foo()的调用位置无关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var a = 2;</div><div class="line">(function()&#123;</div><div class="line">&quot;use strict&quot;;</div><div class="line">foo(); // 2</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。 整个程序要么严格要么非严格。 然而， 有时候你可能会用到第三方库， 其严格程度和你的代码有所不同， 因此一定要注意这类兼容性细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125;</div><div class="line">var obj2 = &#123;</div><div class="line">a: 42,</div><div class="line">foo: foo</div><div class="line">&#125;;</div><div class="line">var obj1 = &#123;</div><div class="line">a: 2,</div><div class="line">obj2: obj2</div><div class="line">&#125;;</div><div class="line">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure></p>
<p>函数调用时，函数中的this取决于该函数点前面是谁，点前面是谁this就代表谁，此处点前面是obj2，所以运行结果为42.<br>当函数执行时前面没有点时，在非严格模式下，this指向(默认绑定)全局window;如果在严格模式下，this会指向undefined,当然会报TypeError: this is undefined。 当函数运行时前面没有点时，要注意有没有显示绑定方法如apply,call和bind，因为它们会显示改变函数中的this。</p>
<p>注意： 对于默认绑定来说， 决定 this 绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式， this 会被绑定到 undefined， 否则<br>this 会被绑定到全局对象。</p>
<h4 id="判断this的规则"><a href="#判断this的规则" class="headerlink" title="判断this的规则"></a>判断this的规则</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</p>
<ul>
<li>1.函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()，构造函数中的this指向当前创建的实例。</li>
<li>2.函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)</li>
<li>3.函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()</li>
<li>4.如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()</li>
<li>5.定时器中的this一直指向window.</li>
</ul>
<h4 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">console.log( this.a );</div><div class="line">&#125; v</div><div class="line">ar a = 2;</div><div class="line">foo.call( null ); // 2</div></pre></td></tr></table></figure></p>
<p>那么什么情况下会传入 null 呢？<br>一种非常常见的做法是使用 apply(..) 来“ 展开” 一个数组， 并当作参数传入一个函数。类似地， bind(..) 可以对参数进行柯里化（ 预先设置一些参数）， 这种方法有时非常有用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 把数组“ 展开” 成参数</div><div class="line">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( null, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>这两种方法都需要传入一个参数当作 this 的绑定对象。 如果函数并不关心 this 的话， 你仍然需要传入一个占位值， 这时 null 可能是一个不错的选择， 就像代码所示的那样。<br>小提示：在 ES6 中， 可以用 … 操作符代替 apply(..) 来“ 展开” 数组， foo(…[1,2]) 和 foo(1,2) 是一样的， 这样可以避免不必要的this 绑定。 可惜， 在 ES6中没有柯里化的相关语法， 因此还是需要使用bind(..)。</p>
<p>然而， 总是使用 null 来忽略 this 绑定可能产生一些副作用。 如果某个函数确实使用了this（ 比如第三方库中的一个函数）， 那默认绑定规则会把 this 绑定到全局对象（ 在浏览<br>器中这个对象是 window）， 这将导致不可预计的后果（ 比如修改全局对象）。（假设要使用bind方法的函数（称为fun1）中使用了第三方库的函数，恰好这个第三库的函数中也有this，此时代码fun1.bind(null，参数1)很有可以会影响到第三库函数中的this）显而易见， 这种方式可能会导致许多难以分析和追踪的 bug。</p>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h4><p>一种“ 更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对程序产生任何副作用。可以创建一个“ DMZ”（ demilitarizedzone， 非军事区） 对象——它就是一个空的非委托的对象.如果我们在忽略 this 绑定时总是传入一个 DMZ 对象， 那就什么都不用担心了， 因为任何对于 this 的使用都会被限制在这个空对象中， 不会对全局对象产生任何影响。<br>在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“ 更空” ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125; </div><div class="line">// 定义的 DMZ 空对象</div><div class="line">var ø = Object.create( null );//ø为变量名，可以随便起。</div><div class="line">// 把数组展开成参数</div><div class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class="line">// 使用 bind(..) 进行柯里化</div><div class="line">var bar = foo.bind( ø, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure></p>
<p>使用变量名 ø 不仅让函数变得更加“ 安全”， 而且可以提高代码的可读性， 因为 ø 表示“ 我希望 this 是空”， 这比 null 的含义更清楚。 当然你可以用任何喜欢的名字来命名 DMZ 对象。</p>
<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h4><p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 =&gt; 定义的。 箭头函数不使用 this 的标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">// 返回一个箭头函数</div><div class="line">return (a) =&gt; &#123;</div><div class="line">//this 继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">var obj1 = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">var obj2 = &#123;</div><div class="line">a:3</div><div class="line">&#125;;</div><div class="line">var bar = foo.call( obj1 );</div><div class="line">bar.call( obj2 ); // 2, 不是 3 ！</div></pre></td></tr></table></figure></p>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不<br>行！ ）<br>箭头函数最常用于回调函数中， 例如事件处理器或者定时器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">// 这里的 this 在此法上继承自 foo()</div><div class="line">console.log( this.a );</div><div class="line">&#125;,100);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">a:2</div><div class="line">&#125;;</div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-this/">js this</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-deepclosure" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/06/deepclosure/" class="article-date">
      <time datetime="2017-02-06T09:32:12.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/06/deepclosure/">深入理解闭包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>闭包定义：当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125;</div><div class="line">bar();//基于词法作用域的查找规则， 函数bar() 可以访问外部作用域中的变量 a</div><div class="line">&#125; </div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>这是真正意义上的闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。最准确地用来解释bar() 对 a 的引用的方法是词法作用域的查找规则， 而这些规则只是闭包的一部分。（ 但却是非常重要的一部分！） 。由于看上去 foo() 的内容不会再被使用， 所以引擎很自然地会考虑对其进行回收。foo()执行完，由于浏览器引擎的垃圾回收机制，foo函数的作用域都会被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function bar() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125;</div><div class="line">return bar;</div><div class="line">&#125;</div><div class="line">var baz = foo();</div><div class="line">baz(); // 2 —— 这才是闭包</div></pre></td></tr></table></figure></p>
<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后， 其返回值（ 也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。 但是在这个例子中，bar()在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为引擎有垃圾回收器用来释放不再使用的内存空间。 而闭包的“ 神奇” 之处正是可以阻止这件事情的发生。在此处事实上foo内部作用域依然存在， 因此没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</p>
<p> 这个函数在定义时的词法作用域以外的地方被调用。 闭包使得函数可以继续访问定义时的词法作用域。<br> 当然， 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a ); // 2</div><div class="line">&#125; </div><div class="line">bar( baz );</div><div class="line">&#125;</div><div class="line">function bar(fn) &#123;</div><div class="line">fn(); // 快看呀， 这就是闭包！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把内部函数 baz 传递给 bar， 当调用这个内部函数时（ 现在叫作 fn）， 它涵盖的 foo() 内部作用域的闭包就可以观察到了， 因为它能够访问 a。传递函数当然也可以是间接的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var fn;</div><div class="line">function foo() &#123;</div><div class="line">var a = 2;</div><div class="line">function baz() &#123;</div><div class="line">console.log( a );</div><div class="line">&#125; </div><div class="line">fn = baz; // 将 baz 分配给全局变量</div><div class="line">&#125;</div><div class="line">function bar() &#123;</div><div class="line">fn(); // 妈妈快看呀， 这就是闭包！</div><div class="line">&#125; </div><div class="line">foo();</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure></p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。</p>
<h4 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上这段代码在运行时会以每秒一次的频率输出五次 6。（在定时器还没有执行完的时候，i的值已经是6了，因为定时器是异步的，for循环是同步的，执行速度可以忽略不记）</p>
<p>正常情况下， 我们对这段代码行为的预期是分别输出数字 1~5， 每秒一次， 每次一个，那该如何做呢？可以利用闭包的特点来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function() &#123;</div><div class="line">var j = i;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以对上面代码进行一些改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">(function(j) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<font color="red">也可以用块作用域来实现</font>

<p>使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。let 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。 因此， 下面这些看起来很酷的代码就可以正常运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">let j = i; // 是的， 闭包的块作用域！</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( j );</div><div class="line">&#125;, j*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然实现了，但是不是最优的，for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=1; i&lt;=5; i++) &#123;</div><div class="line">setTimeout( function timer() &#123;</div><div class="line">console.log( i );</div><div class="line">&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 块作用域和闭包联手便可天下无敌。 有了此功能你就可以成为一名快乐的 JavaScript 程序员了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-closure/">js closure</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 Wenxi Yan
            </div>
            <div class="footer-right">
                <a href="http://webywx.com/" target="_blank">webywx</a>  Theme <a href="https://yanwenxi.site" target="_blank">前端在路上</a> by Scorpio
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >用户到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>