---
title: 性能测试与调优
date: 2017-02-05 09:37:46
tags: js 性能调试 Benchmark jsPerf
---
#### 性能测试
在日常开发中，一般被问到如何测试某个运算的速度（ 执行时间） ， 绝大多数 JavaScript 开发人员都会从类似下面的代码开始：
```
var start = (new Date()).getTime(); // 或者Date.now()
// 进行一些操作
var end = (new Date()).getTime();
console.log( "Duration:", (end - start) );
```
上面这段代码也是我首先能想到的，其实这种方案有很多错误，别担心，下面会介绍正确的测试方法。
如果报告的时间是 0 ， 可能你会认为它的执行时间小于 1ms。 但是， 这并不十分精确。 有些平台的精度并没有达到 1ms， 而是以更大的递增间隔更新定时器。 比如， Windows（ 也就是 IE） 的早期版本上的精度只有 15ms， 这就意味着这个运算的运行时间至少需要这么长才不会被报告为 0 ！

还有， 不管报告的时长是多少， 你能知道的唯一一点就是， 这个运算的这次特定的运行消耗了大概这么长时间。 而它是不是总是以这样的速度运行， 你基本上一无所知。你不知道引擎或系统在这个时候有没有受到什么影响， 以及其他时候这个运算会不会运行得更快。

如果时长报告是 4 呢？ 你能更加确定它的运行需要大概 4ms 吗？ 不能。 它消耗的时间可能要短一些， 而且在获得 start 或end 时间戳之间也可能有其他一些延误。

更麻烦的是， 你也不知道这个运算测试的环境是否过度优化了。 有可能 JavaScript 引擎找到了什么方法来优化你这个独立的测试用例， 但在更真实的程序中是无法进行这样的优化的，那么这个运算就会比测试时跑得慢。所以这样低置信度的测试几乎无力支持你的任何决策。 这个性能测试基本上是无用的。 更坏的是， 它是危险的， 因为它可能提供了错误的置信度，不仅是对你，还有那些没有深入思考带来测试结果的条件的人员。

<font color="red">重复</font>
“也许， ”你现在会说， “那就用一个循环把它包起来， 这样整个测试的运行时间就会更长一些了。 ”如果重复一个运算 100 次，然后整个循环报告共消耗了 137ms， 那你就可以把它除以 100， 得到每次运算的平均用时为 1.37ms， 是这样吗？并不完全是这样。简单的数学平均值绝对不足以对你要外推到整个应用范围的性能作出判断。 迭代 100 次， 即使只有几个（ 过高或过低的） 的异常值也可以影响整个平均值， 然后在重复应用这个结论的时候， 你还会扩散这个误差， 产生更大的欺骗性。

<font color="red">Benchmark.js</font>
任何有意义且可靠的性能测试都应该基于统计学上合理的实践。在这里介绍一个统计学上有效的性能测试工具，名为Benchmark.js. 官网地址：http://benchmarkjs.com/
Benchmark.js当然可以用在浏览器中测试 JavaScript ， 它也可以在非浏览器环境中运行（ Node.js等）。
为了简单展示一下， 下面介绍应该如何使用 Benchmark.js来运行一个快速的性能测试：
```
function foo() {
// 要测试的运算
} v
ar bench = new Benchmark(
"foo test", // 测试名称
foo, // 要测试的函数（也即内容）
{
// .. // 可选的额外选项（参见文档）
}
);
bench.hz; // 每秒运算数
bench.stats.moe; // 出错边界
bench.stats.variance; // 样本方差
```
在上面的代码片段中， 其实忽略了“额外选项”`{ .. }` 对象。 这里有两个选项是我们应该知道的： setup 和 teardown 。这两个选项使你可以定义在每个测试之前和之后调用的函数。
提示：一定要理解， setup 和 teardown 代码不会在每个测试迭代都运行。 最好的理解方法是， 想像有一个外层循环（一轮一轮循环） 还有一个内层循环（一个测试一个测试循环） 。 setup 和 teardown 在每次外层循环（轮） 的开始和结束处运行， 而不是在内层循环中。关于 Benchmark.js的使用还有很多要学的，可以自行谷歌或者度娘。

#### jsPerf.com
尽管在所有的 JavaScript 运行环境下， Benchmark.js 都可用于测试代码的性能， 但有一点一定要强调， 如果你想要得到可靠的测试结论的话， 就需要在很多不同的环境（ 桌面浏览器、 移动设备， 等等） 中测试汇集测试结果。

比如， 针对同样的测试高端桌面机器的性能很可能和智能手机上 Chrome 移动设备完全不同。 而电量充足的智能手机上的结果可能也和同一个智能手机但电量只有 2% 时完全不同，因为这时候设备将会开始关闭无线模块和处理器。如果想要在不止一个环境下得出像“X 比 Y 快”这样的有意义的结论成立， 那你需要在尽可能多的真实环境下进行实际测试。 仅仅因为在 Chrome 上某个 X 运算比 Y 快并不意味着这在所有的浏览器中都成立。 当然你可能还想要交叉引用多个浏览器上的测试运行结果， 并有用户的图形展示。

有一个很棒的网站正是因这样的需求而诞生的， 名为 jsPerf（http://jsperf.com） 。 它使用前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试， 并把测试结果放在一个公开可得的 URL上， 你可以把这个 URL转发给别人。每次测试运行的时候， 测试结果就会被收集并持久化， 累积的测试结果会被图形化， 并展示到一个页面上以供查看。更多学习请参照官网。

#### 尾调用优化
ES6 包含了一个性能领域的特殊要求。 这与一个涉及函数调用的特定优化形式相关： 尾调用优化 （ TailCall Optimization， TCO） 。
简单地说， 尾调用就是一个出现在另一个函数“结尾”处的函数调用。 这个调用结束后就没有其余事情要做了（ 除了可能要返回结果值） 。
以下是一个非递归的尾调用的例子：
```
function foo(x) {
return x;
} f
unction bar(y) {
return foo( y + 1 ); // 尾调用
}function baz() {
return 1 + bar( 40 ); // 非尾调用
} b
az(); // 42
```
foo(y+1) 是 bar(..) 中的尾调用， 因为在 foo(..) 完成后， bar(..) 也完成了， 并且只需要返回 foo(..) 调用的结果。 然而， bar(40) 不是尾调用， 因为在它完成后， 它的结果需要加上 1 才能由 baz() 返回。
调用一个新的函数需要额外的一块预留内存来管理调用栈， 称为栈帧 。 所以前面的代码一般会同时需要为每个 baz() 、 bar(..) 和 foo(..) 保留一个栈帧。
然而， 如果支持 TCO 的引擎能够意识到 foo(y+1) 调用位于尾部 ， 这意味着 bar(..) 基本上已经完成了， 那么在调用foo(..) 时， 它就不需要创建一个新的栈帧， 而是可以重用已有的 bar(..) 的栈帧。 这样不仅速度更快， 也更节省内存。
ES6 确保了 JavaScript 开发者从现在开始可以在所有符合 ES6+ 的浏览器中依赖这个优化。 这对 JavaScript 性能来说是一个胜利。

#### 总结
对一段代码进行有效的性能测试， 特别是与同样代码的另外一个选择对比来看看哪种方案更快， 需要认真注意细节。与其打造你自己的统计有效的性能测试逻辑， 不如直接使用 Benchmark.js 库， 它已经为你实现了这些。 但是， 编写测试要小心， 因为我们很容易就会构造一个看似有效实际却有缺陷的测试， 即使是微小的差异也可能扭曲结果， 使其完全不可靠。

从尽可能多的环境中得到尽可能多的测试结果以消除硬件 / 设备的偏差， 这一点很重要。 jsPerf.com是很好的网站， 用于众包性能测试运行。

尾调用优化是 ES6 要求的一种优化方法。 它使 JavaScript 中原本不可能的一些递归模式变得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行， 不需要任何额外资源。 这意味着， 对递归算法来说， 引擎不再需要限制栈深度。