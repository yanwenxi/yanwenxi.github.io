---
title: 作用域预编译及引发异常问题
date: 2015-02-08 15:13:43
tags: js scope
---
#### 预编译
var a=2;执行分为两个过程：
代码执行前先进行预编译，此时只是声明了一个变量a，此时a的值为undefined，当代码运行到a=2时，变量a才会赋值2。
总结： 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过）， 然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对
它赋值。


#### 类型错误
```
function foo(a) {
console.log( a + b );
b = a;
} 
foo( 2 );
```
上述代码在严格模式中 找不到变量b时（此句对应 console.log( a + b )）， 并不会创建并返回一个全局变量， 引擎会抛出一个ReferenceError 异常。在非严格模式下，如果找不到变量b（此句对应b=a，给b赋值时它会看预编译的时候有没有声明b，如果没有声明，在非严格模式下它会声明并给其赋值），在全局作用域中就会创建一个具有该名称的变量b， 并将其返还给引擎

如果你对一个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。例：
```
var a=12;
var b=null;
```
执行a(),b.property或者b.length都会抛出一个TypeError异常。

总结：ReferenceError 同作用域判别失败相关（在相关作用域内及全局作用域内没有找到变量）， 而 TypeError 则代表作用域判别成功了(在作用域内找到了变量)， 但是对结果的操作是非法或不合理的。

#### 小结
作用域是一套规则， 用于确定在何处以及如何查找变量（ 标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。

赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译， 在这个过程中， 像 var a = 2 这样的声明会被分解成两个独立的步骤：
1.首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。
2.接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值

LHS 和 RHS 查询都会在当前执行作用域中开始， 如果有需要（ 也就是说它们没有找到所需的标识符）， 就会向上级作用域继续查找目标标识符， 这样每次上升一级作用域， 最后抵达全局作用域（ 顶层）， 无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）